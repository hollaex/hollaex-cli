#!/bin/bash 

SCRIPTPATH="$HOME/.hollaex-cli"

#### HollaEx CLI Settings ####

RUN_WITH_VERIFY=true 

LOCAL_DEPLOYMENT_MODE='all'

GENERATE_PASSWORDS=false

DOCKER_COMPOSE_NAME_PREFIX='local'

ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER='api.testnet.hollaex.network'

source $SCRIPTPATH/version_range

err_msg() { echo "$@" ;} >&2
err_msg_a() { err_msg "-a option argument required" ;}
err_msg_l() { err_msg "--long option argument required" ;}

function print_usage() {
/bin/cat << EOF

Usage : 
    hollaex [ dev ] [ server ] [ import ] [ export ] [ login ] [ pull ] [ logout ] [ build ] [ web ] [ toolbox ] [ status ] [ logs ] [ version ] (--flags)

General Flags (Except for 'hollaex init', 'hollaex import'):
    --path, Manually pointing HollaEx Kit path. Should be always absolute path.
    --kube, Set HollaEx CLI to target Kubernetes. Make sure to setup your local kubectl before using it.
    --skip, Run command without user's double confirmation.

Options:
    import: Import settings files generated by using bitHolla Dashboard (dash.bitholla.com).
        --path, Path of file or directory where settings files are stored.
        --with_aws_s3 <BUCKET_NAME>, Import settings files from the remote AWS S3 bucket.

    export: Export settings files to the target location.
        --path, Path of the directory to export settings files.
        --with_aws_s3 <BUCKET_NAME>, Export settings files to the remote AWS S3 bucket.
    
    login: Log in with bitHolla Dashboard account and select my Activation code. 

    pull: Pull the exchange data from the bitHolla Dashboard.

    logout: Log out and remove my bound Activation code on local.

    prod: Bring up the exchange to production. Including public domain setup and SSL configuraiton.

    build: Build the Docker image for running HollaEx Kit, includes user custom configurations.
        --version, Specify base HollaEx Core version for build.

    server: Run and Manage HollaEx Exchange Server.
        --setup: Setup the exchange for the first launch.
        --start: Start the exchange which already been configured by 'hollaex setup' command.
            --tag, Tag name of the new image to apply.
            --ignore_settings, Ignore local settings files changes and not applying it on the server.
        --restart: Restart the existing exchange.
            --tag, Tag name of the new image to apply.
            --ignore_settings, Ignore local settings files changes and not applying it on the server.
        --stop: Stop the exchagne which already been running.
        --upgrade: Upgrade the exchange to new version.
            --version, Version number of HollaEx Core to upgrade.
            --user_image_registry, Specify Docker registry and version (tag) for the user HollaEx Core image.
            --ignore_compatibility_check, Ignore Kit and Core compatibility check before an upgrade.
            --ignore_settings, Ignore local settings files changes and not applying it on the server.
            --api_only, Rolling Upgrade API Pods only for Kubernetes.
        --terminate: Terminate the existing exchange. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE AND CAN'T BE UNDO.
      
    web: Run web server for the exchange.
        --setup, Setup the web server for the first launch.
        --start, Start the web server 
        --stop, Stop the web server.
        --restart, Restart the web server while applying new changes (If it's available).
        --build, Build the web server docker image. This command would not affect the existing web server before restart.
        --terminate, Terminate the web server. THIS COMMAND WILL COMPLETELY REMOVE YOUR WEB CLIENT AND CAN'T BE UNDO.

    toolbox: Toolbox for advanced features which could be helpful for your exchange operations.
        --backup, Run the full backup with 'pg_dumpall' for exchange's PostgreSQL database.
        --set_backup_cronjob, Set the Kubernetes Cronjob for periodical database backup.
        --flush_redis, Run the full flush of Redis stored data.
        --issue_ssl, Issue SSL certificate on local Nginx by using Let's Encrypt.
        --renew_ssl, Renew SSL certificate on local Nginx by using Let's Encrypt.
        --update_registry_secret, Update existing docker registry secret for Kubernetes.
        --set_config, Update constants configured on the exchange database.
        --set_security, Override security values at admin panel for the exchange.
        --set_activation_code, Set or update activation code for the exchange.
        --connect_database, Direct connection to PostgreSQL Database via postgresql-client.
        --connect_redis, Direct connection to Redis via redis-client.
        --install_cli, Install specific version of HollaEx CLI.
        --influxdb_migration, Migrate InfluxDB data to a new InfluxDB.
        --reset_hmac_token, Reset the exchange API key (HMAC Token).

    dev: Running an exchange in a dev mode.
        --setup, Setup an exchange in a dev mode.
        --start, Starting an exchange in a dev mode.
        --stop, Stopping an exchange in a dev mode.
        --restart, Restarting an exchange in a dev mode.
        --terminate, Terminating an exchange in a dev mode.
        --database_init, Running a database initialization job for a dev mode exchange.

    cloud: Operate the exchange running on the HollaCloud.
        --start, Start the stopped exchange exists on the HollaCloud. 
        --stop, Stop the running exchange on the HollaCloud.
        --restart, Restart the running exchange on the HollaCloud.
        --upgrade, Upgrade the running exchange on the HollaCloud with the latest version of HollaEx Kit.
        --terminate, Terminate the existing exchange on the HollaCloud. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE AND CAN'T BE UNDO.

    status: Show the exchange server status.

    logs: Show overview of logs from the exchange server. 

    version: Print out current installed version of HollaEx CLI.

EOF
}

function dev_print_usage() {
/bin/cat << EOF

# All 'hollaex dev' commands should be run at HollaEx Core directory.

Usage : 
    hollaex [ dev ] (--flags)

General Flags :
    --skip, Run command without user's double confirmation.

Options:
    --command: Run Docker-Compose commands. (up, down, stop, --build)

    --database_init: Run database initialization scripts.

EOF
}

if [[ "$1" == "dev" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --command)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_DEV_MANUAL_COMMAND=true
                LOCAL_COMMAND=$1
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --server)
                HOLLAEX_DEV_TARGET="server"
                shift; continue
                ;;
            --web)
                HOLLAEX_DEV_TARGET="web"
                shift; continue
                ;;
            --setup)
                HOLLAEX_DEV_SETUP=true
                shift; continue
                ;;
            --start)
                HOLLAEX_DEV_START=true
                shift; continue
                ;;
            --stop)
 
                HOLLAEX_DEV_STOP=true
              
                shift; continue
                ;;
            --restart)

                HOLLAEX_DEV_RESTART=true

                shift; continue
                ;;
            --terminate)

                HOLLAEX_DEV_TERMINATE=true
         
                shift; continue
                ;;
            --database_init)
                LOCAL_DATABASE_INIT=true
                echo 'Local database initialization enabled.'
                shift; continue
                ;;
            --test)
                LOCAL_CODE_TEST=true
                echo 'Local mocha code test mode enabled.'
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo 'Skipping the command confirmation.'
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                dev_print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    IS_DEVELOP=true

    HOLLAEX_CLI_INIT_PATH=$(pwd)
    CONFIG_FILE_PATH=$(pwd)/settings/*
    TEMPLATE_GENERATE_PATH=$(pwd)/templates
    INIT_PATH_CHECK=$(pwd)/.hollaex

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    
    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    # Checking docker-compose is installed on this machine.
    if command docker-compose version > /dev/null 2>&1; then
        echo "*********************************************"
        echo "docker-compose detected"
        echo "version: $(docker-compose version)"
        echo "*********************************************"

    else
        echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
        exit 1;

    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local;
    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
    fi

    if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
        mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
    fi
    
    # Running database jobs for local db.
    if [[ ! "$LOCAL_COMMAND" ]] && [[ "$LOCAL_DATABASE_INIT" == true ]]; then
    
        local_database_init start;

        docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart

        exit 0;

    fi

    if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

        load_config_variables;

        generate_local_env;

    fi

    if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
    
        if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then
            
            generate_local_docker_compose_for_core_dev;

        else    

            generate_local_docker_compose_for_dev;

        fi

    fi

    generate_nginx_upstream;

    if [[ "$HOLLAEX_DEV_TARGET" == "server" ]]; then 

        if [[ "$HOLLAEX_DEV_SETUP" ]]; then

            CONTINUE_WITH_PRECONFIGURED_VALUES=false 

            hollaex_setup_initialization;
            
            BUILD_HOLLAEX_CORE_VERSION=$HOLLAEX_CONFIGMAP_KIT_VERSION
            BUILD_HOLLAEX_CORE_BRANCH=$(git --git-dir $HOLLAEX_CLI_INIT_PATH/.git rev-parse --abbrev-ref HEAD)
            BUILD_HOLLAEX_CORE_DATE="$(echo $(date +%y%m%d%H%M))"

            BUILD_HOLLAEX_CORE_IMAGE_TAG=${BUILD_HOLLAEX_CORE_VERSION}-${BUILD_HOLLAEX_CORE_BRANCH}-${BUILD_HOLLAEX_CORE_DATE}
            export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=${BUILD_HOLLAEX_CORE_VERSION}-${BUILD_HOLLAEX_CORE_BRANCH}-${BUILD_HOLLAEX_CORE_DATE}

            override_docker_image_version;

            export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE

            build_user_hollaex_core;
            
            #Generating random values for passwords and update config file to contain it;
            update_random_values_to_config;

            # Randomly generates backend passwords
            if [[ ! "$HOLLAEX_SECRET_REDIS_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_PUBSUB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_DB_PASSWORD" ]] ; then
            
                generate_backend_passwords;

            fi

            # Regenerating docker compose file with the new image tag just defined above.
            if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
        
                if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then
                    
                    generate_local_docker_compose_for_core_dev;

                else    

                    generate_local_docker_compose_for_dev;

                fi

            fi

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml up -d  
            
            echo "Installing npm packages for /plugins"
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-api_1 bash -c '
                cd /app/plugins && \
                npm install --loglevel=error && \
                for d in ./*/ ; do (cd "$d" && npm install --loglevel=error); done'

            hollaex dev --database_init
        
            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart

            hollaex_setup_finalization;

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml restart
            
            
        elif [[ "$HOLLAEX_DEV_RESTART" ]]; then

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml stop
            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml up -d

            if [[ ! "$HOLLAEX_DEV_SETUP" ]]; then

                echo "Installing npm packages for /plugins"
                docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server-api_1 bash -c '
                    cd /app/plugins && \
                    npm install --loglevel=error && \
                    for d in ./*/ ; do (cd "$d" && npm install --loglevel=error); done'
            fi 

        else 

            docker-compose -f ${TEMPLATE_GENERATE_PATH}/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml $LOCAL_COMMAND

        fi

        # WEB

    elif [[ "$HOLLAEX_DEV_TARGET" == "web" ]]; then 
        
        if [[ "$HOLLAEX_DEV_SETUP" ]]; then
            
            cd web
            npm install
            npm run start

        fi

    fi

    exit 0;


elif [[ "$1" == "server" ]]; then
    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --setup)
                hollaex setup ${@:2}
                break
                ;;
            --start)
                hollaex start ${@:2}
                break
                ;;
            --stop)
                hollaex stop ${@:2}
                break   
                ;;
            --restart)
                hollaex restart ${@:2}
                break   
                ;;
            --scale)
                hollaex scale ${@:2}
                break   
                ;;
            --upgrade)
                hollaex upgrade ${@:2}
                break
                ;;
            --build)
                hollaex build ${@:2}
                break
                ;;
            --apply)
                hollaex apply ${@:2}
                break
                ;;
            --terminate)
                hollaex terminate ${@:2}
                break
                ;;
            --*) 
                print_usage;
                err_msg "Invalid option: $1"
                exit 1;
                ;;
        esac
        shift
    done

    
elif [[ "$1" == "setup" ]]; then
    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                print_usage;
                err_msg "Invalid option: $1"
                exit 1;
                ;;
        esac
        shift
    done

    export HOLLAEX_IS_SETUP=true

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    echo "Setting the Kit /settings folder as 'assumed-unchanged' state."
    git --git-dir=$HOLLAEX_CLI_INIT_PATH/.git update-index --assume-unchanged ./settings/*

    source $SCRIPTPATH/tools_generator.sh

    system_dependencies_check;

    check_docker_daemon_status;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    # PRESET env for user initial setup config value selection
    CONTINUE_WITH_PRECONFIGURED_VALUES=false 

    hollaex_setup_initialization;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Building the image
    if [[ "$USE_KUBERNETES" ]]; then

        hollaex build --registry ${ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY} --kube --is_hollaex_setup

    else 

        hollaex build --registry ${ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY} --is_hollaex_setup

    fi 

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    # Randomly generates backend passwords
    if [[ ! "$HOLLAEX_SECRET_REDIS_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_PUBSUB_PASSWORD" ]] || [[ ! "$HOLLAEX_SECRET_DB_PASSWORD" ]] ; then
    
        generate_backend_passwords;

    fi
    
    #Generating random values for passwords and update config file to contain it;
    update_random_values_to_config;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mError: HollaEx CLI detected that the exchange exists on your remote Kubernetes environment.\033[39m\n"
            printf "\033[91mCannot setup an exchange multiple times.\033[39m\n\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        #Creating kubernetes_config directory for generating config for Kubernetes.

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to launch $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Generating Kubernetes Configmap."
        generate_kubernetes_configmap;

        echo "Generating Kubernetes Secret."
        generate_kubernetes_secret;
        
        echo "Creating namespace on Kubernetes."
        kubectl create ns $ENVIRONMENT_EXCHANGE_NAME

        echo "Applying configmap on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
        
        echo "Applying secret on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

            echo "Running Redis."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_REQUESTS:-100Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-redis.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)
        
        fi

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql
            echo "Running PostgreSQL DB."

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --wait \
                        --set pvc.create=true \
                        --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" \
                        --set pvc.size="$ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_VOLUMESIZE" \
                        --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_REQUESTS:-100Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

        fi
        
        create_kubernetes_docker_registry_secret;

        run_and_upgrade_hollaex_on_kubernetes;

        if [[ "$ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_ACCESSKEY" ]] && [[ "$ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_SECRETKEY" ]]; then

            echo "Installing PostgreSQL database backup Cronjob..."
            hollaex toolbox --set_backup_cronjob --kube --skip

        fi 

        hollaex_setup_finalization;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"  
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if command docker ps -a | grep local_$ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mError: HollaEx CLI detected that the exchange exists on your machine.\033[39m\n"
            printf "\033[91mExchange setup can't be done for multiple times.\033[39m\n\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        echo "Generating docker-compose file"
        generate_local_docker_compose
        generate_local_env
        generate_nginx_upstream
        apply_nginx_user_defined_values

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then
            
            local_database_init start;

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

            hollaex_setup_finalization;

        else 

            echo "Error: Failed to start the HollaEx server."
            echo "Please check the logs and try it again."
            
            exit 1

        fi

    fi

    exit 0;

elif [[ "$1" == "import" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_IMPORT_PATH_INPUT=$@
                shift; continue
                ;;
            --with_aws_s3)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                TARGET_AWS_S3_BUCKET=$1
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    # HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_IMPORT_PATH <<< "$HOLLAEX_IMPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi

# Storing current CURRENCIES and PARIS
cat > $HOLLAEX_CLI_INIT_PATH/.old/old-currencies-and-pairs <<EOL

OLD_CURRENCIES=$(echo $HOLLAEX_CONFIGMAP_CURRENCIES)
OLD_PAIRS=$(echo $HOLLAEX_CONFIGMAP_PAIRS)

EOL

    if [[ "$TARGET_AWS_S3_BUCKET" ]]; then 

        if [[ "$ENVIRONMENT_EXCHANGE_NAME" == "hollaex" ]] && [[ "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME" ]] ; then

            echo "Error: Your haven't typed the exchange name yet."
            echo "Please type the registered exchange name."
            echo "The name will be used to point the AWS S3 folder."
            read exchangeName
            exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
            
            echo "Your exchange name: $exchangeNameParsed."
            echo "Do you want to proceed with this name? (Y/n)"
            read answer 

            while true;
                do if [[ ! "$answer" = "${answer#[Nn]}" ]]; then 
                    echo "Please type the registered exchange name."
                    read exchangeName
                    exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
                    
                    echo "Your exchange name: $exchangeNameParsed."
                    echo "Do you want to proceed with this name? (Y/n)"
                    read answer
                else
                    break;
                fi
            done

            export ENVIRONMENT_EXCHANGE_NAME=$exchangeNameParsed

        fi 

        mkdir -p $HOLLAEX_CLI_INIT_PATH/.settings-temp

        echo "Pulling the settings files from s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME AWS S3 bucket."
        if ! command aws s3 cp --recursive s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME/ $HOLLAEX_CLI_INIT_PATH/.settings-temp; then

            echo "Error: Failed to pull the settings files from s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."
            echo "Please check the error logs and try again."

            exit 1;

        fi 

        export HOLLAEX_IMPORT_PATH=$HOLLAEX_CLI_INIT_PATH/.settings-temp

    fi 

    if [[ "${HOLLAEX_IMPORT_PATH[@]}" == *"json"* ]]; then

         # Returns error If 'jq' doesn't exists.
        if ! command jq --version > /dev/null 2>&1; then

            printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
            echo "HollaEx CLI requires 'jq' to handle certain functionalities."
            echo "Please install it first and try again."

            printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
            printf "For macOS users with Homebrew: 'brew install jq'\n\n"

            exit 1;

        fi

        echo "Converting imported file to HollaEx CLI settings file format..."

        for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

        done

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

                export SECRET_FILE_PATH=$i

            fi

        done
        
        BITHOLLA_USER_EXCHANGE_LIST=$(cat $HOLLAEX_IMPORT_PATH)

        # SAVING USER ACTIVATION CODE.
        export EXCHANGE_USER_ACTIVATION_CODE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[0].activation_code";);
        sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${EXCHANGE_USER_ACTIVATION_CODE}/" $SECRET_FILE_PATH;
        rm $SECRET_FILE_PATH.bak

        BITHOLLA_USER_EXCHANGE_ORDER=0

        hollaex_pull_and_apply_exchange_data;

        apply_coins_config_to_settings_file;

        apply_pairs_config_to_settings_file;

        if command grep -q "ENVIRONMENT_ADD_COIN_${COIN_PREFIX}_COIN" $CONFIGMAP_FILE_PATH > /dev/null && command grep -q "ENVIRONMENT_ADD_PAIR_${PAIR_PREFIX}" $CONFIGMAP_FILE_PATH > /dev/null; then

            IS_IMPORT_SUCCESS=true

        else 

            IS_IMPORT_SUCCESS=false

        fi

    else 

        rm $CONFIG_FILE_PATH

        for i in ${HOLLAEX_IMPORT_PATH[@]}; do

            if [[ -d "$i" ]]; then
                
                if command cp $i/* $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi

            elif [[ -f "$i" ]]; then

                if command cp $i $IMPORT_FILE_PATH; then

                    IS_IMPORT_SUCCESS=true
                
                else 

                    IS_IMPORT_SUCCESS=false
                
                fi
            
            fi

        done;

        if [[ -d "$HOLLAEX_IMPORT_PATH" ]]; then
            
            if command cp $HOLLAEX_IMPORT_PATH/* $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi

        elif [[ -f "$HOLLAEX_IMPORT_PATH" ]]; then

            if command cp $HOLLAEX_IMPORT_PATH $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            fi
        
        fi

    fi

    if [[ "$IS_IMPORT_SUCCESS" == true ]]; then 

        printf "\033[92mYour settings files has been imported into your HollaEx Kit!\033[39m\n"
        echo "If you are trying to run a brand-new exchange, proceed to run 'hollaex setup'."
        echo "If you are already running the exchange, and trying to apply reconfigured files, run 'hollaex restart'."

    else 

        printf "\033[91m\nFailed to import your files into HollaEx Kit.\033[39m\n"
        echo "Please confirm that you passed the correct path of your settings files (or directory), and try again."

        exit 1;
    
    fi

    if [[ -d "$HOLLAEX_CLI_INIT_PATH/.settings-temp" ]]; then

        rm -r $HOLLAEX_CLI_INIT_PATH/.settings-temp

    fi 

elif [[ "$1" == "export" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_EXPORT_PATH_INPUT=$@
                shift; continue
                ;;
            --with_aws_s3)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                TARGET_AWS_S3_BUCKET=$1
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    # HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_EXPORT_PATH <<< "$HOLLAEX_EXPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi


    if [[ "$TARGET_AWS_S3_BUCKET" ]]; then 

        if [[ "$ENVIRONMENT_EXCHANGE_NAME" == "hollaex" ]] && [[ "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]]; then

            echo "Error: Your haven't typed the exchange name yet."
            echo "Please type the registered exchange name."
            echo "The name will be used to point the AWS S3 folder."
            read exchangeName
            exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
            
            echo "Your exchange name: $exchangeNameParsed."
            echo "Do you want to proceed with this name? (Y/n)"
            read answer 

            while true;
                do if [[ ! "$answer" = "${answer#[Nn]}" ]]; then 
                    echo "Please type the registered exchange name."
                    read exchangeName
                    exchangeNameParsed=$(echo $exchangeName | tr -dc '[:alnum:]\n\r' | tr '[:upper:]' '[:lower:]' | tr -d ' ')
                    
                    echo "Your exchange name: $exchangeNameParsed."
                    echo "Do you want to proceed with this name? (Y/n)"
                    read answer
                else
                    break;
                fi
            done

            export ENVIRONMENT_EXCHANGE_NAME=$exchangeNameParsed

        fi 

        echo "Pushing the settings files to s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME AWS S3 bucket."
        if ! command aws s3 cp --recursive $HOLLAEX_CLI_INIT_PATH/settings s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME; then

            echo "Error: Failed to push the settings files to s3://$TARGET_AWS_S3_BUCKET/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."
            echo "Please check the error logs and try again."

            exit 1;

        fi 

    elif [[ "$HOLLAEX_EXPORT_PATH_INPUT" ]]; then

        echo "Exporting HollaEx Kit settings files to $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME."

        mkdir -p $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings
        mkdir -p $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME
        
        cp $HOLLAEX_CLI_INIT_PATH/settings/* $HOLLAEX_EXPORT_PATH_INPUT/hollaex-kit-settings/$ENVIRONMENT_EXCHANGE_NAME

    fi 

    printf "\033[92mYour settings files has been exported successfully!\033[39m\n"

elif [[ "$1" == "login" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        source $i

    done;

    source $SCRIPTPATH/tools_generator.sh

    hollaex_login_token_validate_and_issue;

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange \
       | jq '.')
    
    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')
    
    # Exit with error if user doesn't have any exchange on the account.
    if [[ "$BITHOLLA_USER_EXCHANGE_COUNT" == "0" ]]; then

        printf "\n\033[91mError: You don't have any exchange on your account.\033[39m\n"
        echo "Please go to the bitHolla Dashboard (dash.bitholla.com), and do an exchange configuration first."
        
        exit 1;

    fi

    # Subtracting 1 from total count due to the array starts from 0, not from 1.
    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    printf "\n"

    function hollaex_login_select_exchange() {

        printf "Please pick the \033[1mexchange number\033[0m you want to bind.\n\n"

        for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        printf "Exchange number : \033[1m$((i+1))\033[0m\n";

        echo "Name:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name");
        echo "Activation Code:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code");
        printf "\n"

        EXCHANGE_NAME_TEMP=EXCHANGE_NAME_${i}
        EXCHANGE_ACTIVATION_CODE_TEMP=EXCHANGE_ACTIVATION_CODE_${i}

        export $(echo $EXCHANGE_NAME_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name";);
        export $(echo $EXCHANGE_ACTIVATION_CODE_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code";);

        done;

        printf "Input the exchange number: "
        read answer

        while true;
            do if [[ ! "${answer}" =~ ^[0-9]+$ ]]; then 
                printf "\033[91m\nError: The input always should be numberic.\033[39m\n"
                echo "Please pick the exchange number you want to bind."
                read answer
            else
                break;
            fi
        done

        answer=$((answer-1))
        
        printf "\n"
        SELECTED_EXCHANGE_NAME=EXCHANGE_NAME_${answer}
        SELECTED_EXCHANGE_ACTIVATION_CODE=EXCHANGE_ACTIVATION_CODE_${answer}

        if [[ ! "${!SELECTED_EXCHANGE_NAME}" ]] || [[ ! "${!SELECTED_EXCHANGE_ACTIVATION_CODE}" ]]; then

            printf "\033[91m\nError: Failed to read the data from the selected exchange.\033[39m\n"
            printf "Please make sure that you selected the correct number, and try again.\n\n"
            hollaex_login_select_exchange;

        fi
        
        echo -e "\033[1mSelected Exchange name: ${!SELECTED_EXCHANGE_NAME}\033[0m"
        echo -e "\033[1mSelected Activation code: ${!SELECTED_EXCHANGE_ACTIVATION_CODE}\033[0m"
        echo "Do you want to continue? (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

            hollaex_login_select_exchange;

        fi
    }

    hollaex_login_select_exchange;

    if command sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${!SELECTED_EXCHANGE_ACTIVATION_CODE}/" $SECRET_FILE_PATH; then

        rm $SECRET_FILE_PATH.bak

        printf "\n\033[92mSuccessfully bound the selected exchange to HollaEx Kit.\033[39m\n"

    else

        printf "\033[91mFailed to bind selected exchange to HollaEx Kit.\033[39m\n"
        echo "Please review the error and try again."
        exit 1;

    fi
    
    # ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER=$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER
    # hollaex_login_form;

    if [[ "$HOLLAEX_SECRET_API_KEY" ]] && [[ "$HOLLAEX_SECRET_API_SECRET" ]]; then 

        echo -e "\n\033[92mHollaEx CLI detected that the HollaEx Network security token is already set on the settings file.\033[39m\n"

        echo "API Key: $HOLLAEX_SECRET_API_KEY"
        echo "Secret Key: $(echo ${HOLLAEX_SECRET_API_SECRET//?/◼︎}$(echo $HOLLAEX_SECRET_API_SECRET | grep -o '....$'))"
        
        echo -e "\nSkipping to issue a security token..."

    elif [[ "$HOLLAEX_LOGIN_RENEW" ]]; then 

        echo "Skipping to issue (revoke) the HMAC security token, since it's a --renew mode."

    else 

        get_hmac_token;

    fi

elif [[ "$1" == "logout" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    printf "\nAre you sure you want to \033[1mlogout\033[0m from bitHolla? (y/N)\n"
    printf "This command \033[1mwould not affect\033[0m your exchange data.\n"
    read answer

    if [[ "$answer" = "${answer#[Yy]}" ]]; then
        echo "Exiting..."
        exit 0;
    fi

    # Removing the login token
    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        rm $HOLLAEX_CLI_INIT_PATH/.token
    
    else 

        printf "\n\033[93mThere was no login data to revoke.\033[39m\n"
    
    fi

    printf "\nPlease run 'hollaex login' if you want to login back.\n"
    printf "Bye!\n\n"

elif [[ "$1" == "pull" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --renew)
                HOLLAEX_LOGIN_RENEW=true
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    # Returns error If 'jq' doesn't exists.
    if ! command jq --version > /dev/null 2>&1; then

        printf "\033[91mError: 'jq' (https://stedolan.github.io/jq/) has not been detected on your system.\033[39m\n"
        echo "HollaEx CLI requires 'jq' to handle certain functionalities."
        echo "Please install it first and try again."

        printf "\nFor Ubuntu (Debian) users: 'apt-get install -y jq'\n"
        printf "For macOS users with Homebrew: 'brew install jq'\n\n"

        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

        printf "\033[91mFailed to read pre-bound Activation code.\033[39m\n"
        echo "'hollaex pull' works only after you successfully logged in."
        echo "Please run 'hollaex login' to sign in first."
        exit 1;
    
    fi

    if [[ "$RUN_WITH_VERIFY" == true ]]; then 

        printf "\nCurrent bound activation code: \033[92m$HOLLAEX_SECRET_ACTIVATION_CODE\033[39m\n\n"
        echo "This command will override the current Exchange settings at '/settings' folder of your HollaEx Kit."
        echo "Are you sure you want to pull the exchange settings from bitHolla Dashboard? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
    
    fi 

    if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

        export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

    else 

        printf "\033[91mError: An access token has not been detected.\033[39m\n"
        printf "Please login with your bitHolla account to issue an access token.\n\n"
        hollaex login --renew

    fi

    BITHOLLA_USER_TOKEN_EXPIRY_CHECK=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
            --request GET \
            https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange)

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange \
       | jq '.')

    if [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" ]] || [[ ! "$BITHOLLA_USER_TOKEN_EXPIRY_CHECK" == "200" ]]; then

        printf "\033[91mFailed to pull the exchange data from bitHolla.\033[39m\n\n"
        printf "\033[91mError: Your access token has been expired!\033[39m\n"
        printf "Please login again with your bitHolla account to issue a new access token.\n\n"
        hollaex login --renew

    else 

        printf "\n\033[92mSuccessfully authenticated on bitHolla Server.\033[39m\n"
        printf "Proceeding to pull data from bitHolla...\n"

    fi

    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')

    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code") == "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

            export BITHOLLA_USER_EXCHANGE_ORDER=$i
        
        fi

    done;

    if [[ $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].is_completed") == false ]]; then

        BITHOLLA_USER_EXCHANGE_UPDATED_DATE=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$BITHOLLA_USER_EXCHANGE_ORDER].updated_at" | cut -f1 -d "T" | tr -d '-')
        BITHOLLA_DASH_1_3_RELEASE_DATE=20200219

        printf "\n\033[91mError: Your exchange is not fully configured at bitHolla Dashboard.\033[39m\n"
        printf "Please finalize the exchange setup at bitHolla Dashboard (https://dash.bitholla.com), and try agian.\n\n"

        if (($BITHOLLA_DASH_1_3_RELEASE_DATE > $BITHOLLA_USER_EXCHANGE_UPDATED_DATE)); then

            printf "\033[1mFor the HollaEx users who updated the exchange before Feb 19th, 2020.\033[0m\n"
            printf "You should \033[1mgo through the exchange setup once more\033[0m to update your exchange status.\n"
            printf "You don't need to update any vaules on the dashboard if it's not required.\n\n"

        fi

        exit 1;

    fi

    hollaex_pull_and_apply_exchange_data;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    if [[ ! "$ENVIRONMENT_EXCHANGE_NAME" == "hollaex" ]] && [[ ! "$HOLLAEX_CONFIGMAP_API_NAME" == "my-hollaex-exchange" ]]; then

        printf "\n\033[92mSuccessfully pulled and applied your exchange data to Hollaex Kit!\033[39m\n\n"

        if [[ ! "$RUN_WITH_VERIFY" ]]; then

            echo "You can now proceed to run 'hollaex setup' to initialize your brand-new exchange."
            printf "If you already have existing exchange, Please run 'hollaex restart' to apply new configurations.\n"
            
        fi

    else

        printf "\033[91mError: Failed to pull and apply data from bitHolla.\033[39m\n"
        echo "Please review the logs and try it again."
        exit 1;

    fi


elif [[ "$1" == "start" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

     # Override user HollaEx Core tag if the flag is available.
    if [[ "$HOLLAEX_CORE_USER_APPLY_TAG" ]]; then
        
        override_user_docker_tag;

    fi

    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 
        
    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        #Generating and updating settings

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        if [[ ! "$IGNORE_SETTINGS" ]]; then 

            echo "Applying configmap on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

            echo "Applying secret on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml
        
        fi 

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=${ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS:-1} --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME
                        
            echo "Applying Ingress rules..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            echo "All done!"
            echo "Containers successfully scaled up"

            hollaex_ascii_exchange_is_up;

            exit 0;

        else 

            echo "HollaEx CLI failed to detect existing exchange running on this Kubernetes."
            echo "Please review your settings files and targeted Kubernetes."

            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi  
        
        # Generating docker-compose yaml for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream;
        
        fi

        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then

            hollaex_ascii_exchange_is_up;
        
        else 

            printf "\033[91mFailed to start exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

    fi

    exit 0;

elif [[ "$1" == "scale" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_SCALE_TARGET=$1
                echo "Scaling Target: $HOLLAEX_SCALE_TARGET."
                shift; continue
                ;;
            --replicas)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_SCALE_TARGET_REPLICAS=$1
                echo "Target Replicas: $HOLLAEX_SCALE_TARGET_REPLICAS."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    export ENVIRONMENT_HOLLAEX_SCALEING=true

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

     source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 
        
    fi 

     # Target filtering

    SUPPORTED_TARGETS=("api" "stream")

    if [[ "$HOLLAEX_SCALE_TARGET" ]]; then

        if ! command printf '%s\n' ${SUPPORTED_TARGETS[@]} | grep $HOLLAEX_SCALE_TARGET > /dev/null; then

            echo "Error: The specified target $HOLLAEX_SCALE_TARGET is not supported for scaling."
            echo "Supported targets: ${SUPPORTED_TARGETS[@]}."
            echo "Please try it again."

            exit 1;

        fi 

        export HOLLAEX_SCALE_TARGET_CONVERTED="${ENVIRONMENT_EXCHANGE_NAME}-server-${HOLLAEX_SCALE_TARGET}"

    else

        echo "Error: You must specify the target server for scaling with '--target' flag."
        echo "Please try it again."

        exit 1;

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$HOLLAEX_SCALE_TARGET_CONVERTED --replicas=$HOLLAEX_SCALE_TARGET_REPLICAS --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            export HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS="ENVIRONMENT_KUBERNETES_$(echo $HOLLAEX_SCALE_TARGET | tr '[:lower:]' '[:upper:]')_SERVER_REPLICAS"

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/$HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS=.*/$HOLLAEX_SCALE_TARGET_REPLICAS_SETTINGS=$HOLLAEX_SCALE_TARGET_REPLICAS/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done

            printf "\033[92m\nTarget $HOLLAEX_SCALE_TARGET has been successfully scaled to $HOLLAEX_SCALE_TARGET_REPLICAS.\033[39m\n"

            exit 0;

        else 

            printf "\033[91mFailed to scale the target $HOLLAEX_SCALE_TARGET! Please review your settings and try again.\033[39m\n"
            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        # Checking that the existing docker-compose file got the host port bound specifications.
        if command cat $TEMPLATE_GENERATE_PATH/local/${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml | grep -e "10010" -e "10080" > /dev/null 2>&1; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Running docker-compose scale command.
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --no-recreate --scale $HOLLAEX_SCALE_TARGET_CONVERTED=$HOLLAEX_SCALE_TARGET_REPLICAS; then
            
            # Nginx Reload
            docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

            printf "\033[92m\nTarget $HOLLAEX_SCALE_TARGET has been successfully scaled to $HOLLAEX_SCALE_TARGET_REPLICAS.\033[39m\n"
        
        else 

            printf "\033[91mFailed to scale the target $HOLLAEX_SCALE_TARGET! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

    fi

    exit 0;


elif [[ "$1" == "prod" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    # for i in ${CONFIG_FILE_PATH[@]}; do
    #     source $i
    # done;
    
    source $SCRIPTPATH/tools_generator.sh
    # load_config_variables;

    if [[ "$RUN_WITH_VERIFY" == true ]]; then

        
        printf "\nPreparing the exchange for production deployment\n\n"

        echo -e "This command is going to apply \033[1mproduction domain\033[0m to your exchange."
        echo -e "Before you proceed make sure you have your own exchange domain. (Required)"
        echo -e "\033[1mAre you ready to proceed? (Y/n)\033[0m"

        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

    fi

    function hollaex_prod_domain_questions() {

        # Web Domain
        echo "***************************************************************"
        echo "Exchange Web Domain"
        printf "\033[2m- Enter the full domain of your exchange website, without 'http' or 'https'.\033[22m\n"
        read answer
        
        while true;
            do if [[ "$answer" == *"http"* ]]; then
                printf "\nValue should be an URL without 'http' or 'https'.\n\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            elif [[ -z "$answer" ]]; then
                printf "\nThe value should not be empty!\n"
                echo  "Exchange Web Domain: "
                read answer
                local INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
            else
                break;
            fi
        done

        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN="${answer}"
        export INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP="http://${answer}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTP//\//\\/}

        printf "\n"
        echo "${INPUT_HOLLAEX_CONFIGMAP_DOMAIN} ✔"
        printf "\n"

        #Automatically mark the API url as api.<MY_DOMAIN>
        export INPUT_HOLLAEX_CONFIGMAP_API_HOST="api.${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"
        local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${INPUT_HOLLAEX_CONFIGMAP_API_HOST}"
        local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        printf "Since you selected the Exchange Web domain as: \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN,\033[0m\n"
        printf "Your Exchange Server \033[1mAPI domain\033[0m would be: \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[0m.\n"
        printf "Type \033[1m'Y'\033[0m to continute, or \033[1m'N'\033[0m to modify the Exchange Server API domain. (Y/n)\n"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
        
            # API Domain
            echo "***************************************************************"
            echo "Exchange Server API Domain"
            printf "\033[2m- Enter the full domain of your exchange API server, without 'http' or 'https'.\033[22m\n"
            read answer

            while true;
                do if [[ "$answer" == *"http"* ]]; then
                    printf "\nValue should be an URL without 'http' or 'https'.\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                elif [[ -z "$answer" ]]; then
                    printf "\nThe value should not be empty!\n\n"
                    echo  "Exchange API Domain: "
                    read answer
                    local INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"
                else
                    break;
                fi
            done

            export INPUT_HOLLAEX_CONFIGMAP_API_HOST="${answer}"

            printf "\n"
            echo "${INPUT_HOLLAEX_CONFIGMAP_API_HOST} ✔"
            printf "\n"

            local INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP="http://${answer}"
            local PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTP//\//\\/}

        fi 

        export HOLLAEX_CONFIGMAP_DOMAIN=$INPUT_HOLLAEX_CONFIGMAP_DOMAIN
        export HOLLAEX_CONFIGMAP_API_HOST=$INPUT_HOLLAEX_CONFIGMAP_API_HOST

        printf "\nYour Exchange Web Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN\033[39m"
        printf "\nYour Exchange API Domain: \033[92m$INPUT_HOLLAEX_CONFIGMAP_API_HOST\033[39m\n"
        echo "Type 'Y' to proceed (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
            hollaex_prod_domain_questions;

        else 

            echo "Updating user settings file based on the provided values..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done
        
        fi

    }

    # Asking for domains questions for production.
    hollaex_prod_domain_questions;

    #Checking the domains are reachable
    function hollaex_prod_check_domains_reachability() {
        
        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_DOMAIN > /dev/null; then

            printf "\n\033[92mSuccessfully resolved the exchange web URL ($INPUT_HOLLAEX_CONFIGMAP_DOMAIN).\033[39m\n"
            HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=true

        else 

            HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY=false
        
        fi

        if command nslookup $INPUT_HOLLAEX_CONFIGMAP_API_HOST > /dev/null; then

            printf "\n\033[92mSuccessfully resolved the exchange API URL ($INPUT_HOLLAEX_CONFIGMAP_API_HOST).\033[39m\n"
            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=true

        else

            HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY=false
        
        fi

        if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]] || [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

            # Announcing the domain configuration how-to.
            SYSTEM_PUBLIC_IP=$(curl -s ifconfig.me)

            if [[ ! "$SYSTEM_PUBLIC_IP" ]]; then
                printf "\n\033[91mError: Failed to get the system public IP automatically.\033[39m\n"
                echo "You should check it by yourself."
                SYSTEM_PUBLIC_IP="<YOUR_PUBLIC_IP>"
            fi

            printf "\n\nYour Public IP: $SYSTEM_PUBLIC_IP.\n\n"

            if [[ "$HOLLAEX_PROD_EXCHANGE_WEB_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_DOMAIN.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_DOMAIN to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."
            fi

            if [[ "$HOLLAEX_PROD_EXCHANGE_API_URL_REACHABLILITY" == "false" ]]; then

                printf "\n\033[93mThe domain DNS setup is required for $INPUT_HOLLAEX_CONFIGMAP_API_HOST.\033[39m\n"
                printf "\nPlease set an \033[1mA RECORD\033[0m for \033[1m$INPUT_HOLLAEX_CONFIGMAP_API_HOST to point $SYSTEM_PUBLIC_IP\033[0m.\n"
                printf "It is recommended to set the \033[1mTTL shorter\033[0m to apply DNS rule faster.\n\n"
                read -p "Press enter once you configured the DNS."

            fi

            printf "\n\033[93mChecking the DNS reachability...\033[39m\n"
            echo "Info: You could always quit the DNS checking loop with 'Crtl + C'."
            hollaex_prod_check_domains_reachability;

        fi
    }

    hollaex_prod_check_domains_reachability;

    apply_nginx_user_defined_values;

    printf "\n"

    if [[ ! "$USE_KUBERNETES" ]]; then
    
        echo "Do you want to issue SSL cert for your exchange? (Y/n)"
        echo "If you are going to use an external load balancer with SSL, Please type 'N'."

    elif [[ "$USE_KUBERNETES" ]]; then

        echo "HollaEx CLI natively supports issuing SSL cert through 'cert-manager' and Let's encrypt."
        echo "Please make sure to install latest 'cert-manager' on your Kubernetes cluster."
        echo "Official document is available for installation. (cert-manager.io/docs/installation/kubernetes)"

        printf "\n"

        echo "Do you want to set up cert-manager issuer name for SSL? (Y/n)"
        echo "If you are going to use an external load balancer with SSL, Please type 'N'."

    fi
    
    read answer 

    printf "\n"

    if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
    
        echo "Skipping to issue SSL cert..."
        printf "\n\n\033[93mInfo: You could also issue SSL cert later by running 'hollaex toolbox --issue_ssl' command.\033[39m\n"

    else 

        if [[ "$USE_KUBERNETES" ]]; then
        
            echo "The 'cert-manager' requires an issuer name to reach SSL ACME service."
            echo "Please provide your cert-manager issuer name."
            read answer

            echo "Updating the issuer name on user's settings file..."
            for i in ${CONFIG_FILE_PATH[@]}; do

                # Update exchange name
                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=.*/ENVIRONMENT_KUBERNETES_INGRESS_CERT_MANAGER_ISSUER=$answer/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
                fi
                
            done

            printf "\n"
            echo "$answer ✔"
            printf "\n"

        elif [[ ! "$USE_KUBERNETES" ]]; then

            echo "HollaEx CLI natively supports issuing SSL cert through 'certbot' and Let's encrypt."
            echo "Running 'certbot' now..."
            printf "\n"
            while true;
                do if command hollaex toolbox --issue_ssl --skip; then

                    echo "Do you want to issue more SSL cert for different domain? (Y/n)"
                    read answer

                    if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                        echo "Skipping..."
                        break;

                    else 

                        hollaex toolbox --issue_ssl --skip;
                        break;

                    fi
                
                else 

                    printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
                    exit 1;

                fi

            done;

            
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "HOLLAEX_CONFIGMAP_API_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i
                fi 
            
            done

            echo "Do you want to enable cert-manager based SSL for API server? (Y/n)"
            read answer

             if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
            
                echo "Skipping to enable SSL for API server..."

                 if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=false/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=false" >> $CONFIGMAP_FILE_PATH

                fi

            else 

                export ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true

                if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_SERVER=true" >> $CONFIGMAP_FILE_PATH

                fi

                printf "\n"
                echo "✔"
                printf "\n"
            
            fi 

            echo "Do you want to enable cert-manager based SSL for Web server? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
            
                echo "Skipping to enable SSL for Web server..."

                if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=false/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=false" >> $CONFIGMAP_FILE_PATH

                fi

            else 

                export ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true

                if command grep -q "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB" $CONFIGMAP_FILE_PATH > /dev/null ; then
            
                    echo "Updating the existing ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB value..."
                    sed -i.bak "s/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=.*/ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak

                else 

                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB is missing on your settings file. Adding it now..."
                    echo "ENVIRONMENT_KUBERNETES_INGRESS_SSL_ENABLE_WEB=true" >> $CONFIGMAP_FILE_PATH

                fi

                printf "\n"
                echo "✔"
                printf "\n"
            
            fi 
        
        fi

        echo "Updating domains on settings files to use 'https' as a prefix..."

        INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_DOMAIN}"
        PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN=${INPUT_HOLLAEX_CONFIGMAP_DOMAIN_WITH_HTTPS//\//\\/}

        INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS="https://${INPUT_HOLLAEX_CONFIGMAP_API_HOST}"
        PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST=${INPUT_HOLLAEX_CONFIGMAP_API_HOST_WITH_HTTPS//\//\\/}

        for i in ${CONFIG_FILE_PATH[@]}; do

            # Update exchange name
            if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                CONFIGMAP_FILE_PATH=$i
                sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$PARSED_INPUT_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$PARSED_INPUT_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                rm $CONFIGMAP_FILE_PATH.bak
            fi
            
        done

    fi

    hollaex_prod_complete;

    exit 0;

elif [[ "$1" == "stop" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
           --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT_MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done
    
    # Export hollaex-kit directory

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$USE_KUBERNETES" ]]; then
        

         #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Scaling down containers on the cluster..."
        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        echo "Scaling down backend components..."

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        hollaex_ascii_exchange_has_been_stopped;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop $HOLLAEX_CONFIGMAP_API_NAME running on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            hollaex_ascii_exchange_has_been_stopped;

        else 

            printf "\033[91mFailed to stop exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

    fi

    exit 0;

elif [[ "$1" == "restart" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --silent)
                HOLLAEX_SILENT=true
                echo "Silent mode is enable. Some of the outputs will not be displayed."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done
    
    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

    # Override user HollaEx Core tag if the flag is available.
    if [[ "$HOLLAEX_CORE_USER_APPLY_TAG" ]]; then
        
        override_user_docker_tag;

    fi

     if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        hollaex server --stop --skip --kube

        hollaex server --start --skip --kube
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            printf "\033[91mHollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI.\033[39m\n"
            
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        hollaex server --stop --skip

        hollaex server --start --skip

    fi

    exit 0;

elif [[ "$1" == "build" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE

    # Update the Core version to the user specified version, or use a latest compatible one.
    export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(cat $HOLLAEX_CLI_INIT_PATH/server/package.json | jq -r '.version')"
    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-core-${ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE}-$(date +%y%m%d%H%M)"

    build_user_hollaex_core;

    echo -e "\nPlease run 'hollaex apply --registry $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION $(if [[ "$USE_KUBERNETES" ]]; then echo "--kube"; fi)' to apply it on the server."

elif [[ "$1" == "apply" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target Docker Image Registry: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$1
                echo "Target Docker Image tag: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY=${ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY}
    ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=${ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION}

    if [[ "$RUN_WITH_VERIFY" == true ]]; then

        printf "\033[93mWarning: Exchange service will be unavailable while applying the new image!\033[39m\n"
        echo "Are you sure you want to apply the $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY:$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION image on your exchange? (y/N)"

        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

    fi

    export ENVIRONMENT_USER_REGISTRY_OVERRIDE=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY
    override_user_docker_registry;
    

    export HOLLAEX_CORE_USER_APPLY_TAG=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION
    override_user_docker_tag;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi
    
        run_and_upgrade_hollaex_on_kubernetes;
        
    else 

        hollaex restart --skip 

        local_database_init upgrade

        hollaex restart --skip 

    fi

    hollaex_ascii_exchange_has_been_upgraded;


elif [[ "$1" == "upgrade" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target Docker Image Registry: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$1
                echo "Target Docker Image tag: $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --ignore_settings)
                IGNORE_SETTINGS=true
                echo "HollaEx CLI will ignore local settings update on restart."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    source $SCRIPTPATH/tools_generator.sh

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    # Update random secrets if env generation is enabled.
    if [[ ! "$IGNORE_SETTINGS" ]]; then 

        #Regenerate random secrets
        update_random_values_to_config;

    fi

    # Update HollaEx CLI to latest if there is newer release available.
    update_hollaex_cli_to_latest;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then

        echo "Checking the version compatibility between the latest HollaEx CLI and your local Kit..."
        if command curl -s -f https://raw.githubusercontent.com/bitholla/hollaex-cli/master/version_range > $SCRIPTPATH/.master_version_range; then 

            source $SCRIPTPATH/.master_version_range
            rm $SCRIPTPATH/.master_version_range

        else 

            printf "\n\033[91mError: Failed to read latest version compatibility range from the server.\n\033[39m"
            echo "Please check your internet connectivity and try it again."
            
            exit 1;

        fi

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;

    fi

    #hollaex build
    
    # Update the Core version to the user specified version, or use a latest compatible one.
    export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE="$(cat $HOLLAEX_CLI_INIT_PATH/server/package.json | jq -r '.version')"
    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-core-${ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE}-$(date +%y%m%d%H%M)"
    
    export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE=$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION

    build_user_hollaex_core;

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    load_config_variables;

    if [[ "$IGNORE_SETTINGS" ]]; then

        export ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE=false
        export ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE=false 

    fi 

    if [[ "$USE_KUBERNETES" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE --kube

        else 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE --kube --skip

        fi

    else

        if [[ "$RUN_WITH_VERIFY" == true ]]; then 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE 

        else 

            hollaex apply --tag $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION_OVERRIDE --skip

        fi

    fi

elif [[ "$1" == "terminate" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --ignore_compatibility_check)
                IGNORE_COMPATIBILITY_CHECK=true
                echo "Warning: HollaEx CLI will ignore all compatibility checkes for HollaEx Core and Kit."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$IGNORE_COMPATIBILITY_CHECK" ]]; then 

        # Check Kit version compatibility range.
        check_kit_version_compatibility_range;
    
    fi 

    echo -e "\n# # # # # #  \033[1mW A R N I N G\033[0m  # # # # # #\n"
    echo -e "\033[91mYou are now trying to TERMINATE your exchange!\033[39m"
    echo -e "Terminating the exchange will \033[91mREMOVE\033[39m all of your \033[91mFUNDS, USER DATA, and EVERYTHING.\033[39m"
    echo -e "This action \033[91mCANNOT BE UNDO\033[39m, and will make the exchange \033[91mUNRECOVEREABLE for eternally.\033[39m"
    echo -e "\n# # # # # # # # # # # # # # # # # # # #\n"

    sleep 5

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo -e "\033[91mTHIS IS YOUR LAST CHANCE TO CANCEL IT!\033[39m\n"

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

         # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Running a final backup for the exchange database."
        if ! command hollaex toolbox --backup --kube --skip; then 

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                printf "\033[91mWarning: HollaEx CLI failed to make a final DB backup!\n"
                echo "Do you want to continue without a DB backup? (y/N)"

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            else 

                printf "\033[91mWarning: HollaEx CLI failed to make a final DB backup!\n"
                echo "Proceeding without a backup..."

            fi
            
        fi

        echo "Removing helm packages on the cluster."
        helm uninstall $ENVIRONMENT_EXCHANGE_NAME-server-api --namespace $ENVIRONMENT_EXCHANGE_NAME 
        helm uninstall $ENVIRONMENT_EXCHANGE_NAME-server-stream --namespace $ENVIRONMENT_EXCHANGE_NAME

        helm uninstall $ENVIRONMENT_EXCHANGE_NAME-redis --namespace $ENVIRONMENT_EXCHANGE_NAME
        helm uninstall $ENVIRONMENT_EXCHANGE_NAME-db --namespace $ENVIRONMENT_EXCHANGE_NAME
        #Remove web server together if it exists on same namespace.
        if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null ; then
            
            helm uninstall $ENVIRONMENT_EXCHANGE_NAME-web --namespace $ENVIRONMENT_EXCHANGE_NAME

        fi

        echo "Removing $HOLLAEX_CONFIGMAP_API_NAME namespace."
        kubectl delete ns $ENVIRONMENT_EXCHANGE_NAME

        hollaex_ascii_exchange_has_been_terminated;

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated."
        echo "If there's an issue, please review the logs and try it again."
        printf "\nBye!\n\n"

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo -e "\033[91mTHIS IS YOUR LAST CHANCE TO CANCEL IT!\033[39m\n"

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Running a final backup for the exchange database."
        if ! command hollaex toolbox --backup --skip; then 

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                printf "\033[91mWarning: HollaEx CLI failed to make a final DB backup!\n"
                echo "Do you want to continue without a DB backup? (y/N)"

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            else 

                printf "\033[91mWarning: HollaEx CLI failed to make a final DB backup!\n"
                echo "Proceeding without a backup..."

            fi
            
        fi

        docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml down --remove-orphans -v

        # Remove web server together if it exists.
        if [[ -f "$TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml" ]] ; then

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down 
        fi

        hollaex_ascii_exchange_has_been_terminated;

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated."
        echo "If there's an issue, please review the logs and try it again."
        printf "\nBye!\n\n"

        exit 0;

    fi

elif [[ "$1" == "web" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "Setting target to Kubernetes..."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --setup)
                WEB_CLIENT_SETUP=true
                shift; continue
                ;;
            --start)
                WEB_CLIENT_START=true
                shift; continue
                ;;
            --stop)
                WEB_CLIENT_STOP=true
                shift; continue
                ;;
            --restart)
                WEB_CLIENT_RESTART=true
                shift; continue
                ;;
            --build)
                WEB_CLIENT_REBUILD=true
                shift; continue
                ;;
            --apply)
                WEB_CLIENT_APPLY=true
                shift; continue
                ;;
            --upgrade)
                WEB_CLIENT_UPGRADE=true
                shift; continue
                ;;
            --terminate)
                WEB_CLIENT_TERMINATE=true
                shift; continue
                ;;
            # Build related
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex web image registry : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --tag)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE=$1
                echo "Target hollaex web image tag : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            # Scale related
            --scale)
                WEB_CLIENT_SCALE=true
                shift; continue
                ;;
            --replicas)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_WEB_SCALE_TARGET_REPLICAS=$1
                echo "Target Replicas: $HOLLAEX_WEB_SCALE_TARGET_REPLICAS."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # Setting web operation enabled command to true.
    ENVIRONMENT_WEB_ENABLE=true

    if [[ ! "$USE_KUBERNETES" ]]; then

         if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    
    elif [[ "$USE_KUBERNETES" ]]; then

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

    fi

    # hollaex web --setup
    if [[ "$WEB_CLIENT_SETUP" ]]; then

        export OVERRIDE_THE_WEB_IMAGE_TAG=true

        if [[ "$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE" ]]; then 
        
            export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY=$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE
        
        fi 

        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to setup the web server on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi
            
            # Web server installation status checking.
            if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: You already installed the web server on your Kuberentes cluster!\033[39m\n"
                echo "To start it, Please run 'hollaex web --start --kube' command instead."

                exit 1;
            
            fi

            #Creating kubernetes_config directory for generating config for Kubernetes.
            if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
                mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            
            # Create docker registry secret on Kubernetes.
            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            # FOR GENERATING NODESELECTOR VALUES
            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

            echo "Running the web server on Kubernetes..."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS:-1}" \
                        --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_WEB_HPA_ENABLE:-false}" \
                        --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_WEB_HPA_AVGMEMORY:-500000000}" \
                        --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_WEB_HPA_MAXREPLICAS:-4}" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_LIMITS:-1000m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_LIMITS:-1024Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_REQUESTS:-2m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_REQUESTS:-100Mi}" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then


                echo "Scaling down the web server after the initialization..."
                hollaex web --stop --kube --skip

                hollaex_ascii_web_server_has_been_setup;
            
            else 

                printf "\n\033[91mFailed to setup the web server on the Kubernetes!\033[39m\n"
                echo "Please review the logs and try again."

                helm uninstall $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null;

                exit 1;

            fi

            exit 0;
        
        elif [[ ! "$USE_KUBERNETES" ]]; then

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to setup the web server on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

                    echo "Restoring old web Nginx configuration file"
                    cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

                    rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

                else

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf
                
                fi

            fi

            echo "Generating web Nginx upstream file"
            generate_nginx_upstream_for_web

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex web --stop --skip

                hollaex_ascii_web_server_has_been_setup;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review the logs and try again."
                exit 1;
            
            fi

            exit 0;

        fi

        exit 0;

    fi

    if [[ "$WEB_CLIENT_START" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start (scale up) the web server on this cluster? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi
            
            # Web server installation status checking.
            if ! command helm ls --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
                echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

                exit 1;
            
           fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml


            if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                create_kubernetes_docker_registry_secret;
            
            fi

            echo "Starting (Scaling up) the web server on Kubernetes..."
            if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 ; then

                hollaex_ascii_web_server_is_up;
            
            else 

                printf "\033[91mFailed to start the web on your Kubernetes cluster!033[39m\n"
                echo "Please review the logs and try again."

                exit 1;

            fi
        

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if ! command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

                echo "Error: Can't detect built web docker image on this machine!"
                echo "If this is your first time launching the web server, please run 'hollaex web --setup' instead."
                echo "You can also build the image manually by using 'hollaex web --build' command."

                exit 1;
              
            fi

            # Checking docker-compose is installed on this machine.
            check_docker_compose_is_installed;

            # if [[ "$RUN_WITH_VERIFY" == true ]]; then

            #     echo "Are you sure you want to start the web client on this machine? (Y/n)"

            #     read answer

            #     if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
            #         echo "Exiting..."
            #         exit 0;
            #     fi

            # fi

            if ! command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

                printf "\033[91m\nError: Failed to detect stopped web server on this machine.\033[39m\n"
                echo "If you haven't setup the web server yet, Please run 'hollaex web --setup' first."

                exit 1;

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]] || [[ ! -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                if [[ -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]] && [[ -s "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf" ]]; then

                    echo "Restoring old web Nginx configuration file"
                    cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

                    rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf

                else

                    echo "Generating web Nginx configuration file"
                    generate_hollaex_web_local_nginx_conf
                
                fi

            fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client start; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_STOP" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) the web server on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Web server installation status checking.
        echo "Checking the web installation status on your Kubernetes..."
        if ! command helm ls --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null 2>&1; then

            printf "\033[91mFailed to detect the web server installed on your Kubernetes cluster.\033[39m\n"
            echo "If you haven't launched the web server yet, Please run 'hollaex web --setup --kube' to set it up first."

            exit 1;
        
        fi

        echo "Removing web ingress rules from the Kubernetes"
        kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        echo "Stopping (Scaling down) the web server..."
        if command kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME; then

            printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
            echo "To bring it up, Please run 'hollaex web --start --kube' command".
        
        else 

            printf "\033[91m\nError: Failed to stop the web server on the Kubernetes.\033[39m\n"
            echo "Please review the logs and try again."

            exit 1;
        
        fi
    
        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to stop the web client on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            # echo "Cleaning up the web Nginx configuration..."
            # cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            # rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then

                # echo "Reloading Nginx..."
                # if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                #     printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                # else

                #     printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                # fi

                printf "\n\033[92mSuccessfully stopped the web server.\033[39m\n"
                echo "To bring it up, Please run 'hollaex web --start' command".

            else 

                printf "\n\033[91mError: Failed to stop the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

        fi

        exit 0;
        
    fi

    if [[ "$WEB_CLIENT_RESTART" ]]; then

        # if [[ "$RUN_WITH_VERIFY" == true ]]; then

        #     if command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

        #         printf "\nPre-built image for web server has been detected on your system.\n"
        #         echo "You should build the image again if you made code changes for web."
        #         echo "Plase input 'Y' to skip the build, 'N' to build the image again."
        #         echo "Do you want to proceed with the pre-built image? (Y/n)"
        #         read answer 

        #         if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

        #             export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        #             echo "Building the web server image..."
        #             build_user_hollaex_web;
                
        #         else 

        #             echo "Proceeding..."
                
        #         fi
            
        #     else 

        #         export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        #         echo "Building the web server image..."
        #         build_user_hollaex_web;

        #     fi

        # else 

        #     export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        #     echo "Building the web server image..."
        #     build_user_hollaex_web;

        # fi

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web ingress rules for Kubernetes"
            generate_kubernetes_ingress_for_web;

            echo "Applying web ingress rules for Kubernetes"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml
            
            # FOR GENERATING NODESELECTOR VALUES
            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATELESS_NODESELECTOR:-$ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateless

            echo "Restarting the $HOLLAEX_CONFIGMAP_API_NAME web server."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                        --set stable.replicaCount="${ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS:-1}" \
                        --set autoScaling.hpa.enable="${ENVIRONMENT_KUBERNETES_WEB_HPA_ENABLE:-false}" \
                        --set autoScaling.hpa.avgMemory="${ENVIRONMENT_KUBERNETES_WEB_HPA_AVGMEMORY:-500000000}" \
                        --set autoScaling.hpa.maxReplicas="${ENVIRONMENT_KUBERNETES_WEB_HPA_MAXREPLICAS:-4}" \
                        --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_LIMITS:-1000m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_LIMITS:-1024Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_WEB_CPU_REQUESTS:-2m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_WEB_MEMORY_REQUESTS:-100Mi}" \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateless.yaml \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web; then

                # Scaling up the web in case of it gets already scaled down.
                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

                echo -e "\n\033[92mSuccessfully restarted the web server on the Kubernetes!\033[39m\n"

                hollaex_ascii_web_server_is_up;
               
            else 

                printf "\033[91mFailed to restart the web server.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi
                
            fi

            echo "Generating web docker-compose file"
            generate_local_docker_compose_for_web

            echo "Generating web .env file"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                echo "Generating web Nginx configuration file"
                generate_hollaex_web_local_nginx_conf

            fi

            echo "Updating main Nginx.conf based on user settings..."
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then
                
                docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"
                    echo "The web server could be still reachable through 'http://localhost:8080',"
                    echo "But the allocated domain for the web would not function correctly."

                fi

                hollaex_ascii_web_server_is_up;

            else 

                printf "\n\033[91mError: Failed to restart the web server.\033[39m\n"
                echo "Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_UPGRADE" ]];  then
        
        export OVERRIDE_THE_WEB_IMAGE_TAG=true 

        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY}
        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE_PARSED=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY}
        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION}

        override_user_hollaex_web;

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        if [[ "$USE_KUBERNETES" ]]; then

                hollaex web --restart --kube --skip

        else 

                hollaex web --restart --skip

        fi

        exit 0;

    fi

    if [[ "$WEB_CLIENT_REBUILD" ]];  then
        
        export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION="${ENVIRONMENT_EXCHANGE_NAME}-web-$(cat version)-$(date +%y%m%d%H%M)"
        build_user_hollaex_web;

        echo -e "\nPlease run 'hollaex web --apply --registry $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY --tag $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION $(if [[ "$USE_KUBERNETES" ]]; then echo "--kube"; fi)' to apply it on the server."

        exit 0;

    fi

    if [[ "$WEB_CLIENT_APPLY" ]];  then

        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE_PARSED=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY}
        ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE=${ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE:-$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION}
        
        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange web service will be unavailable while applying the new image!\033[39m\n"
            echo "Are you sure you want to apply the $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE_PARSED:$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION_OVERRIDE image on your exchange web? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        override_user_hollaex_web

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        if [[ "$USE_KUBERNETES" ]]; then

                hollaex web --restart --kube --skip

        else 

                hollaex web --restart --skip

        fi

    fi

    if [[ "$WEB_CLIENT_TERMINATE" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web server on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Removing web ingress rule on the cluster"
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            echo "Removing the web server..."
            if command helm uninstall --namespace $ENVIRONMENT_EXCHANGE_NAME $ENVIRONMENT_EXCHANGE_NAME-web; then

                printf "\n\033[92mWeb server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup --kube' if you want to set it up again."
            
            else 

                printf "\033[91mFailed to terminate the web server from the Kubernetes.\033[39m\n"
                echo "Please review the logs and try agian."
                exit 1;

            fi

            exit 0;
                

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_is_installed;

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate the web client on this machine? (y/N)"
                echo "This can't be undo."

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Cleaning up the web Nginx configuration..."
            cp -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/.web.conf
            rm $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down --remove-orphans; then

                echo "Reloading Nginx..."
                if command docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload; then
                
                    printf "\n\033[92mSuccessfully reloaded the Nginx\033[39m\n"
        
                else

                    printf "\033[93mFailed to reload Nginx. Please make sure to start the exchange API server first.\033[39m\n"

                fi

                printf "\n\033[92mThe web server has been successfully terminated.\033[39m\n"
                echo "Please run 'hollaex web --setup' to set it up again."

            else 

                printf "\033[91mHollaEx CLI failed to terminate the web server. Please review your settings and try again.\033[39m\n"
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_SCALE" ]]; then

        if [[ ! "$HOLLAEX_WEB_SCALE_TARGET_REPLICAS" ]]; then

            echo -e "\nError: Target replicas number is not specified."
            echo -e "Please use --replicas flag to specify the replicas number.\n"

            exit 1;

        fi

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            # For scaling up exisitng Exchange on Kubernetes
            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

                echo "Scaling up containers on the cluster..."
                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=$HOLLAEX_WEB_SCALE_TARGET_REPLICAS --namespace $ENVIRONMENT_EXCHANGE_NAME
                
                for i in ${CONFIG_FILE_PATH[@]}; do

                    # Update exchange name
                    if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                        CONFIGMAP_FILE_PATH=$i
                        sed -i.bak "s/$ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS=.*/$ENVIRONMENT_KUBERNETES_WEB_SERVER_REPLICAS=$HOLLAEX_WEB_SCALE_TARGET_REPLICAS/" $CONFIGMAP_FILE_PATH
                        rm $CONFIGMAP_FILE_PATH.bak
                    fi
                    
                done

                printf "\033[92m\nWeb server has been successfully scaled to $HOLLAEX_WEB_SCALE_TARGET_REPLICAS.\033[39m\n"

            else 

                printf "\033[91mFailed to scale the target $HOLLAEX_WEB_SCALE_TARGET_REPLICAS! Please review your settings and try again.\033[39m\n"
                exit 1;

            fi

        else

            generate_local_docker_compose_for_web;

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down

            # Running docker-compose scale command.
            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d --no-recreate --scale $ENVIRONMENT_EXCHANGE_NAME-web=$HOLLAEX_WEB_SCALE_TARGET_REPLICAS; then
                
                # Nginx Reload
                # docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

                printf "\033[92m\nWeb server has been successfully scaled to $HOLLAEX_WEB_SCALE_TARGET_REPLICAS.\033[39m\n"
            
            else 

                printf "\033[91mFailed to scale the web server! Please review your settings and try again.\033[39m\n"
                exit 1;
            
            fi

        fi

    fi

    exit 0

elif [[ "$1" == "toolbox" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --dev)
                IS_DEVELOP=true
                echo "HollaEx CLI is configured as dev mode for development purpose."
                shift; continue
                ;;
            --upgrade_backends)
                UPGRADE_BACKENDS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will upgrade your backends (PostgreSQL, Redis) based on your settings files value."
                shift; continue
                ;;
            --backup)
                BACKUP_POSTGRESQL=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run PostgreSQL database dump on your initialized exchange folder."
                shift; continue
                ;;
            --set_backup_cronjob)
                KUBERNETES_SET_BACKUP_POSTGRESQL_CRONJOB=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will install PostgreSQL database dump cronjob on your Kubernetes cluster."
                shift; continue
                ;;
            --flush_redis)
                FLUSH_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run full flush of Redis stored data. This could be helpful in certain situation If the exchange doesnt work properly."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            
            --issue_ssl)
                ISSUE_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to issue SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
            --renew_ssl)
                RENEW_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to renew SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
             --update_registry_secret)
                UPDATE_REGISTRY_SECRET=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your docker image registry secret for Kubernetes."
                shift; continue
                ;;
            --set_activation_code)
                SET_ACTIVATION_CODE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your activation code for the exchange."
                shift; continue
                ;;
            --check_constants)
                CHECK_CONSTANTS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will check and update your database constants."
                shift; continue
                ;;
            --set_config)
                SET_CONFIG=true
                TOOLBOX_ENABLE=true
                echo "Override database-stored cosntants with local configmap-stored values."
                shift; continue
                ;;
            --set_security)
                set_security=true
                TOOLBOX_ENABLE=true
                echo "Override exchange secret values with provided ones."
                shift; continue
                ;;
             --connect_database)
                CONNECT_DATABASE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via postgresql-client."
                shift; continue
                ;;
             --connect_redis)
                CONNECT_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via redis-client."
                shift; continue
                ;;
            --install_cli)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                INSTALL_CLI_ENABLE=true
                INSTALL_CLI_TARGET=$1
                TOOLBOX_ENABLE=true
                shift; continue
                ;;
            --reset_hmac_token)
                RESET_HMAC_TOKEN=true
                TOOLBOX_ENABLE=true
                echo "Getting the HMAC Token from the bitHolla server."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    # For dev command legacy mode
    if [[ "$HOLLAEX_DEV_FOR_CORE" ]]; then

        HOLLAEX_CODEBASE_PATH=$(pwd)

        HOLLAEX_CLI_INIT_PATH=$HOLLAEX_KIT_PATH
        CONFIG_FILE_PATH=$HOLLAEX_KIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_KIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_KIT_PATH/.hollaex

    fi

    # PATH overriding for develop    
    if [[ "$IS_DEVELOP" ]]; then

        if [[ "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$HOLLAEX_CODEBASE_PATH/.hollaex

        elif [[ ! "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$(pwd)/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$(pwd)/.hollaex
            HOLLAEX_CODEBASE_PATH=$(pwd)

        fi

    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    if [[ ! "$TOOLBOX_ENABLE" ]]; then
    
        print_usage;
        echo "No features are enabled for toolbox. Please recheck the command."
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    #Creating kubernetes_config directory for generating config for Kubernetes.
    if [[ "$USE_KUBERNETES" ]]; then 
        
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! -f "$TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex-stateful.yaml" ]]; then

            generate_nodeselector_values ${ENVIRONMENT_KUBERNETES_EXCHANGE_STATEFUL_NODESELECTOR:-ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR} hollaex-stateful

        fi

    else 

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

    fi

    # Features
    if [[ "$UPGRADE_BACKENDS" ]]; then 

        printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"

        echo "All workload containers will be restarted once the upgrade process is done."
    
        if [[ "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis) to latest compatible on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Deleting Ingress rules for the exchange..."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            
            if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

                echo "Upgrading PostgreSQL DB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set pvc.create=true \
                        --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" \
                        --set pvc.size="$ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_VOLUMESIZE" \
                        --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_POSTGRESQL_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_POSTGRESQL_MEMORY_REQUESTS:-100Mi}" \
                        -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" ]]; then

                echo "Upgrading Redis"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                        --set resources.limits.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_LIMITS:-100m}" \
                        --set resources.limits.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_LIMITS:-200Mi}" \
                        --set resources.requests.cpu="${ENVIRONMENT_KUBERNETES_REDIS_CPU_REQUESTS:-10m}" \
                        --set resources.requests.memory="${ENVIRONMENT_KUBERNETES_REDIS_MEMORY_REQUESTS:-100Mi}" \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)

            fi

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            sleep 10;

            echo "Applying Ingress rules for the exchange..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "All workload containers will be restarted once the upgrade process is done."

            echo "Regenerating docker-compose file..."
            generate_local_docker_compose $ENVIRONMENT_EXCHANGE_RUN_MODE

            echo "Restarting containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

            exit 0;

        fi

    elif [[ "$BACKUP_POSTGRESQL" ]]; then

        # Check pg_dump is available on your local
        if command pg_dumpall --version > /dev/null 2>&1; then

            echo "pg_dump detected on your machine!"
            pg_dumpall --version

        else 

            echo "HollaEx CLI failed to detect pg_dump on your machine"
            echo "Please make sure that you already installed pg_dump"

            exit 1;

        fi 

        if [[ ! -d $HOLLAEX_CLI_INIT_PATH/backups ]]; then

            echo "Creating '/backups' folder on HollaEx Kit directory"
            mkdir $HOLLAEX_CLI_INIT_PATH/backups

        fi

        if [[ "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will open proxy tunnel between your machine and remote proxy with kubectl proxy."

            echo "Opening local proxy on 5432 port of your machine..."
            kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &

            echo "Waiting for the proxy tunnel get fully ready..."
            sleep 10;
            
            echo "Running pg_dumpall..."
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost

            pg_dumpall > "${HOLLAEX_CLI_INIT_PATH}"/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-"$(date +%y%m%d%H%M)".dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved at ${HOLLAEX_CLI_INIT_PATH}/backups folder"

            echo "Killing the opened proxy tunnel..."
            kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

            exit 0;

        fi

        if [[ ! "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_DOCKER_COMPOSE_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will backup your local PostgreSQL DB."

            echo "Running pg_dumpall..."
            
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost
            pg_dumpall > $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved at ${HOLLAEX_CLI_INIT_PATH}/backups folder"

            exit 0;

        fi

    elif [[ "$KUBERNETES_SET_BACKUP_POSTGRESQL_CRONJOB" ]]; then

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to install cronjob for database backup on this cluster? (y/N)"
                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            generate_db_s3_backup_cronjob_config;

            echo "Installing cronjob for database backup on Kubernetes."
            if command helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db-backup-s3 \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        -f $TEMPLATE_GENERATE_PATH/kubernetes/config/db-s3-backup-cronjob.yaml \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres-s3-backup-cronjob; then
                
                echo "The cronjob has been installed successfully!"

                echo "The job will be triggered by following $ENVIRONMENT_KUBERNETES_S3_BACKUP_CRONJOB_RULE rule."
                
                exit 0;

            else 

                echo "Failed to install the cronjob at the Kubernetes cluster."
                echo "Please check the error logs and try again."

                exit 1;

            fi
            
        
        elif [[ ! "$USE_KUBERNETES" ]] ; then

            echo "HollaEx CLI only supports install cronjob for database backup on Kubernetes environment."
            echo "Please use --kube flag to target Kubernetes."

            exit 1;

        fi
        
    elif [[ "$FLUSH_REDIS" ]]; then

        printf "\033[93mWarning: Exchange service will be unavailable during the flush!\033[39m\n"

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run flush Redis data on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Flushing Redis..."
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to to run flush Redis data on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Shutting down Nginx to block exchange external access"
            docker stop $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ")

            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
            
            echo "Flushing Redis..."
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

            sleep 10;

            exit 0;
        fi

    elif [[ "$ISSUE_SSL_CERT" ]]; then
        
        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to issue SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi
        fi

        echo "Issuing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot --nginx; then
            
            echo "SSL cert has been successfully set."
            echo "All the Let's encrypt related files can be found at ./templates/local/letsencrypt."

            echo "Updating domanin configurations to use HTTPS at user settings file..."

            UPDATED_HOLLAEX_CONFIGMAP_API_HOST=${HOLLAEX_CONFIGMAP_API_HOST//http:/https:}
            UPDATED_HOLLAEX_CONFIGMAP_DOMAIN=${HOLLAEX_CONFIGMAP_DOMAIN//http:/https:}

            ESCAPED_HOLLAEX_CONFIGMAP_API_HOST=${UPDATED_HOLLAEX_CONFIGMAP_API_HOST//\//\\/}
            ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN=${UPDATED_HOLLAEX_CONFIGMAP_DOMAIN//\//\\/}

            for i in ${CONFIG_FILE_PATH[@]}; do
                if command grep -q "ENVIRONMENT_EXCHANGE_NAME" $i > /dev/null ; then
                    CONFIGMAP_FILE_PATH=$i

                    sed -i.bak "s/HOLLAEX_CONFIGMAP_API_HOST=.*/HOLLAEX_CONFIGMAP_API_HOST=$ESCAPED_HOLLAEX_CONFIGMAP_API_HOST/" $CONFIGMAP_FILE_PATH
                    sed -i.bak "s/HOLLAEX_CONFIGMAP_DOMAIN=.*/HOLLAEX_CONFIGMAP_DOMAIN=$ESCAPED_HOLLAEX_CONFIGMAP_DOMAIN/" $CONFIGMAP_FILE_PATH
                    rm $CONFIGMAP_FILE_PATH.bak
                fi
            done

            if command docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME-web > /dev/null ; then

                printf "\n\033[93mWarning: You should rebuild and restart your web server to apply SSL configuraion on the web.\033[39m\n\n"
                echo "The web server would malfunction if the server doesn't get rebuild"
                echo "Please run 'hollaex web --restart' to rebuild the image and apply."
                printf "\n"

            fi

            printf "\n\nNote: The SSL certificate issued by Let's Encrypt requires a \033[1mrenewal in every 3 months.\033[0m\n"
            printf "Please make sure to run '\033[1mhollaex toolbox --renew_ssl\033[0m' to renew your SSL certificate before it gets expired.\n"
            printf "\nIt is recommended to \033[1msetup a Cronjob\033[0m to automate the renewal process.\n"

            exit 0;

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
 
        
    
    elif [[ "$RENEW_SSL_CERT" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to renew SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Renewing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot renew; then
        
            echo "SSL cert has been successfully renewed."
            echo "All Let's encrypt related files can be found at ./templates/local/letsencrypt."

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
      

    elif [[ "$UPDATE_REGISTRY_SECRET" ]]; then

        if [[ ! "$USE_KUBERNETES" ]]; then 

            echo "Warning: Docker registry secret update is only available for Kubernetes."
            echo "Please use 'hollaex toolbox --update_registry_secret --kube' command instead."
            exit 1;

        fi

        check_kubernetes_dependencies;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        echo "Are you sure that you want to update your existing Docker registry secret at this Kubernets cluster? (y/N)"
        read answer 

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

        echo "Removing the current Docker registry secret at $ENVIRONMENT_EXCHANGE_NAME namespace."
        kubectl delete secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME

         if [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL" ]]; then

            echo "Docker registry credentials are detected at your configmap file."

            echo "*********************************************"
            echo "Docker Registry Host: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_HOST"
            echo "Docker Registry Email: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL"
            echo "Docker Registery Username: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME"
            echo "Docker Registry Password: $(echo ${ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD//?/◼︎}$(echo $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD | grep -o '....$'))"
            echo "*********************************************"
            echo "You can either proceed with this values, or set it again manually by yourself."
            echo "Do you want to proceed with this values? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                echo "Proceeding to a from to re-fill up the credentials."
                MANUAL_DOCKER_REGISTRY_SECRET_UPDATE=true

            fi
        
        fi

        create_kubernetes_docker_registry_secret;
    
    elif [[ "$SET_ACTIVATION_CODE" ]]; then
        
        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;
        
            echo "*********************************************"
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            echo "Are you sure that you want to update your activation code for the exchange on this Kubernets cluster? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart --kube' to fully apply it."


        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            echo "Are you sure that you want to update your activation code for the exchange on this machine? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart' to fully apply it."

        fi

    elif [[ "$CHECK_CONSTANTS" ]]; then

        function toolbox_set_constants_confirm_message() {

            echo "This command would check and update the missing database constants, based on your settings files."
            echo "The missing value could be caused by an upgrade or an error at exchange initialization."
            echo "Do you want to proceed? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_constants_confirm_message;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            check_constants_exec;
            
        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            toolbox_set_constants_confirm_message; 

            toolbox_set_config_confirm_message;
            
            generate_local_env;

            check_constants_exec;

        fi


    elif [[ "$SET_CONFIG" ]]; then

        function toolbox_set_config_confirm_message() {

            echo "Warning: This command is not recommended for most of users in most of use cases."
            echo "This command would completely override your database to update values with local settings."
            echo "Are you sure you want to update database-stored constatns with your local configmap values? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_config_confirm_message;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            set_config_exec;
            
        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            check_docker_compose_dependencies; 

            toolbox_set_config_confirm_message;
            
            generate_local_env;

            set_config_exec;

        fi

    elif [[ "$set_security" ]]; then

        function toolbox_set_security_confirm_message() {

            echo "Warning: This command would override security values* values of your exchange with new ones provided."
            echo "*Security values: Allowed domains, Allowed Admin IPs, reCaptcha Access & Secret keys."
            echo "Do you want to continue? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        }

        if [[ "$USE_KUBERNETES" ]]; then 

            toolbox_set_security_confirm_message;

            set_security_input;

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

             echo "Applying configmap on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
            
            echo "Applying secret on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml
            
            set_security_exec;
            

        elif [[ ! "$USE_KUBERNETES" ]]; then 
        
            check_docker_compose_dependencies; 

            toolbox_set_security_confirm_message;

            set_security_input;

            set_security_exec;

        fi



    elif [[ "$CONNECT_DATABASE" ]]; then

        if ! command psql --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect postgresql-client at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for database connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &
                sleep 5;
                
                echo "Opening local proxy on 5432 port of your machine..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                echo "Opening postgresql-client shell..."
                psql 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect PostgreSQL database at your Kubernetes which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."

                echo "Opening postgresql-client shell..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                psql 

                exit 0;

            else

                echo "Failed to detect PostgreSQL database at your machine which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_REDIS" ]]; then

        if ! command rdcli --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect redis-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for Redis connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-redis" -o name | sed 's/pod\///' | head -n 1) 6379:6379 &
                sleep 5;
                
                echo "Opening local proxy on 6379 port of your machine..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                echo "Opening redis-client shell..."
                redis-cli 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect Redis at your Kubernetes which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."

                echo "Opening redis-cli shell..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                redis-cli 

                exit 0;

            else

                echo "Failed to detect Redis at your machine which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi
    
    elif [[ "$INSTALL_CLI_ENABLE" ]]; then

        if [[ ! "$INSTALL_CLI_TARGET" ]]; then

            echo "Error: You must specify version of the CLI to downgrade."
            echo "eg. 'hollaex toolbox --install_cli 1.8.5'."

            exit 1;

        fi

        echo "Are you sure you want to install HollaEx CLI v$INSTALL_CLI_TARGET? (y/N)"
        read answer

        if [[ "$answer" = "${answer#[Yy]}" ]]; then
            echo "Exiting..."
            exit 0;
        fi
 
        bash $SCRIPTPATH/install.sh $INSTALL_CLI_TARGET

    elif [[ "$RESET_HMAC_TOKEN" ]]; then

        for i in ${CONFIG_FILE_PATH[@]}; do
            source $i
        done;

        load_config_variables;

        for i in ${CONFIG_FILE_PATH[@]}; do

            if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

                export SECRET_FILE_PATH=$i

            fi

        done

        echo -e "\033[91m\nWarning: Running this command will REVOKE your existing token without any additional confirmation!\033[39m\n"

        if [[ ! "$RUN_WITH_VERIFY" == false ]]; then 

            echo "Are you sure you reset (get) the HMAC token for your exchange? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

            unset answer
        
        fi 

        if [[ -f "$HOLLAEX_CLI_INIT_PATH/.token" ]]; then

            export BITHOLLA_ACCOUNT_TOKEN=$(cat $HOLLAEX_CLI_INIT_PATH/.token)

        else 

            printf "\033[91mError: An access token has not been detected.\033[39m\n"
            printf "Please login with your bitHolla account to issue an access token.\n\n"
            hollaex login --renew

        fi

        get_hmac_token;

        echo "To apply the new HMAC Token on your exchange, please run 'hollaex toolbox --set_security (--kube)."
        echo "Note: The 'hollaex toolbox --set_security' command would also set the security related values to the default."
        echo "Please make sure that it's all good to rollback the security settings to the default, before proceeding."

    fi

elif [[ "$1" == "cloud" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kit_repo)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLOUD_CUSTOM_KIT_REPO="${1:-https://github.com/bitholla/hollaex-kit.git}"
                echo "Your Custom HollaEx Kit Git Repository : $HOLLAEX_CLOUD_CUSTOM_KIT_REPO."
                shift; continue
                ;;
            --kit_branch)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH="${1:-master}"
                echo "Your Custom HollaEx Kit Git Branch : $HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --start)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_START=true
                shift; continue
                ;;
            --stop)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_STOP=true
                shift; continue
                ;;
            --restart)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_RESTART=true
                shift; continue
                ;;
            --upgrade)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_UPGRADE=true
                shift; continue
                ;;
            --terminate)
                HOLLAEX_CLOUD_INPUT=true
                HOLLAEX_CLOUD_TERMINATE=true
                shift; continue
                ;;
            # Build related
            --user_image_registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                export ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$USE_KUBERNETES" ]]; then

         if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    
    elif [[ "$USE_KUBERNETES" ]]; then

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

    fi

    if [[ ! "$HOLLAEX_CLOUD_INPUT" ]]; then 

        print_usage

        echo -e "\033[91mError: You haven't specified any action for the 'hollaex cloud' command.\033[39m"
        echo -e "Please check the command list above and try it again.\n"

        exit 1;

    fi 
    
    hollaex_login_token_validate_and_issue;

    # # # FIGURE OUT THE EXCHANGE ID # # #
    HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST=$(curl -s -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
          --request GET \
          https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange)

    HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r '.data[].name')

    j=0
    for i in ${HOLLAEX_CLOUD_GET_EXCHANGE_NAME_LIST[@]}; do 

        if [[ "$i" == "$HOLLAEX_CONFIGMAP_API_NAME" ]]; then

            EXCHANGE_ARRAY_ORDER=$j

        fi

        ((j++))

    done

    HOLLAEX_CLOUD_EXCHANGE_ID=$(echo $HOLLAEX_CLOUD_GET_EXCHANGE_INFO_REQUEST | jq -r ".data[$EXCHANGE_ARRAY_ORDER].id")
    
    # # # END # # # 

    if [[ "$HOLLAEX_CLOUD_START" ]]; then 

        echo -e "\nSending a request to start the stopped exchange on the HollaCloud..."

        # HOLLAEX_CLOUD_START_API_REQUEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Content-Type: application/json" \
        # -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        # --request POST \
        # --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"start\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        # https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange/cloud) 

        HOLLAEX_CLOUD_START_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"start\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange/cloud) 

        HOLLAEX_CLOUD_START_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_START_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_START_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_START_API_REQUEST | cut -f2 -d "&")

        
        if [[ "$HOLLAEX_CLOUD_START_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to start your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 
            
            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_START_API_REQUEST_RESPONSE_PARSE\n"
            echo -e "Please review the logs, and try it again.\n"

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_STOP" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to stop the running exchange on the HollaCloud..."

        HOLLAEX_CLOUD_STOP_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"stop\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange/cloud) 

        HOLLAEX_CLOUD_STOP_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_STOP_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_STOP_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_STOP_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_STOP_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to stop your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_STOP_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi
    
    elif [[ "$HOLLAEX_CLOUD_RESTART" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to restart the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to restart the running exchange on the HollaCloud..."

        HOLLAEX_CLOUD_RESTART_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"restart\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange/cloud) 

        HOLLAEX_CLOUD_RESTART_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_RESTART_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_RESTART_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_RESTART_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_RESTART_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to restart your exchange.\033[39m\n"
            echo "The job would take around 10~20 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_RESTART_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_UPGRADE" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Warning: The upgrade would cause a downtime on your exchange."
            echo "Are you sure you want to upgrade the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to upgrade the running exchange on the HollaCloud..."

        echo -e "\n# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"
        echo "Your HollaEx Kit Git repository: ${HOLLAEX_CLOUD_CUSTOM_KIT_REPO:-'https://github.com/bitholla/hollaex-kit.git'}"
        echo "Your HollaEx Kit Git branch: ${HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH:-'master'}"
        echo -e "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #"

        HOLLAEX_CLOUD_UPGRADE_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"upgrade\", \"data\": { \"kit_repo\": \"$HOLLAEX_CLOUD_CUSTOM_KIT_REPO\", \"kit_branch\": \"$HOLLAEX_CLOUD_CUSTOM_KIT_BRANCH\", \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\"}}" \
        https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange/cloud) 

        HOLLAEX_CLOUD_UPGRADE_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_UPGRADE_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_UPGRADE_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_UPGRADE_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_UPGRADE_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to stop your exchange.\033[39m\n"
            echo "The job would take around 20~30 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_UPGRADE_API_REQUEST_RESPONSE_PARSE\n"
            echo "Please review the logs, and try it again."

            exit 1;

        fi

    elif [[ "$HOLLAEX_CLOUD_TERMINATE" ]]; then 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Warning: The termination could not be undo."
            echo "Are you sure you want to TERMINATE the $HOLLAEX_CONFIGMAP_API_NAME on the HollaCloud? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo -e "\nSending a request to TERMINATE the running exchange on the HollaCloud..."
        echo "Warning: This can't be undo."

        HOLLAEX_CLOUD_TERMINATE_API_REQUEST=$(curl -s -w "&%{http_code}" -H "Content-Type: application/json" \
        -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN" \
        --request POST \
        --data "{\"exchange_id\": ${HOLLAEX_CLOUD_EXCHANGE_ID}, \"command\": \"terminate\", \"data\": { \"exchange_name\": \"$HOLLAEX_CONFIGMAP_API_NAME\", \"agent\": \"CLI v$(cat $SCRIPTPATH/version)\" }}" \
        https://$ENVIRONMENT_HOLLAEX_NETWORK_TARGET_SERVER/v2/exchange/cloud) 

        HOLLAEX_CLOUD_TERMINATE_API_REQUEST_RESPONSE_PARSE=$(echo $HOLLAEX_CLOUD_TERMINATE_API_REQUEST | cut -f1 -d "&" | jq -r '.message')
        HOLLAEX_CLOUD_TERMINATE_API_REQUEST_HTTP_CODE=$(echo $HOLLAEX_CLOUD_TERMINATE_API_REQUEST | cut -f2 -d "&")
        
        if [[ "$HOLLAEX_CLOUD_TERMINATE_API_REQUEST_HTTP_CODE" == "200" ]]; then 

            echo -e "\n\033[92mSuccessfully sent the request to the HollaCloud to terminate your exchange.\033[39m\n"
            echo "The job would take around 20~30 minutes."
            echo -e "We will inform you through the email once it's done!\n"

            exit 0;
        
        else 

            echo -e "\n\033[91mFailed to send the request to the server.\033[39m"
            echo -e "$HOLLAEX_CLOUD_TERMINATE_API_REQUEST_RESPONSE_PARSE\n"
            echo -e "Please review the logs, and try it again.\n"

            exit 1;

        fi

    fi

    exit 0;
    

elif [[ "$1" == "status" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        kubectl get deployment --namespace $ENVIRONMENT_EXCHANGE_NAME

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect HollaEx on this machine. Please try it again.\033[39m\n"

        else 

            docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME

        fi

    fi

    printf "\nCalling the exchange health page ($HOLLAEX_CONFIGMAP_API_HOST/v2/health) ...\n"

    if command curl $HOLLAEX_CONFIGMAP_API_HOST/v2/health; then 

        printf "\n\033[92mSuccessfully reached to the exchange health page.\033[39m\n"

    else 

        printf "\033[91m\nExchange health page is not responding. Please check the exchange is up.\033[39m\n"

    fi

    exit 0;

elif [[ "$1" == "logs" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET=$1
                echo "Displaying Logs from $1..."
                shift; continue
                ;;
            # --lines and --line does same thing.
            --lines)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
            --line)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
           --export)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                echo "Exporting the result as a file."
                HOLLAEX_LOGS_EXPORT=true
                HOLLAEX_LOGS_EXPORT_PATH=$1
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        print_usage;
        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    function hollaex_log_target_whitelist() {

        local whitelist=("api" "stream" "db" "redis")

        if ! command printf '%s\n' ${whitelist[@]} | grep $HOLLAEX_LOGS_TARGET > /dev/null; then
        
            printf "\033[91mError: Invalid target $HOLLAEX_LOGS_TARGET.\033[39m\n"
            echo "Command 'hollaex logs' only supports '${whitelist[@]}' as log target."
            echo "Pleases try it again."

            exit 1;

        fi
    }
    
    if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

        hollaex_log_target_whitelist;
    
    fi

    if [[ -d "$HOLLAEX_LOGS_EXPORT_PATH" ]]; then

        export HOLLAEX_LOGS_EXPORT_PATH="${HOLLAEX_LOGS_EXPORT_PATH}/hollaex-logs-$(date +%s).log"

    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        function show_kubernetes_logs_simple() {

            hollaex version

            # Printing general system information
            echo "Client System OS Type: $OSTYPE"
            echo "Client System Shell Type: $SHELL"
            echo "Client System Shell Version: $(${SHELL} --version)"

            printf "\nKubernetes Version: $(kubectl version)\n\n"
            echo "Helm Version: $(helm version)"

            printf "\n#########################################################################\n"

            if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-*-$HOLLAEX_LOGS_TARGET | cut -f1 -d " ")

            else 
                
                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | cut -f1 -d " ")
            
            fi

            for i in ${POD_ID[@]}; do

                printf "\nPod : $i\n"

                    if [[ $(kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail 10) ]]; then

                            kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail ${HOLLAEX_LOGS_TARGET_LINE:-100}

                    else 

                        echo "There are no logs for Pod : $i."

                    fi

                printf "\n"

            done;
        
        }

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            show_kubernetes_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

        else 

            show_kubernetes_logs_simple
        
        fi


        printf "\n"
        echo "Displayed (Saved) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from pod(s)."

        if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then
            
            echo "To see logs from specific pod(s), Please run 'hollaex logs --kube --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
            echo "For example, 'hollaex logs --kube --target api --lines 20'."
        
        fi

        if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

            printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
            exit 0;

        fi

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect $ENVIRONMENT_EXCHANGE_NAME on this machine. Please try it again.\033[39m\n"

        else 

            function show_docker_logs_simple() {

                hollaex version

                # Printing general system information
                echo "System OS Type: $OSTYPE"
                echo "System Shell Type: $SHELL"
                echo "System Shell Version: $(${SHELL} --version)"

                printf "\n#########################################################################\n"

                if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-.*-$HOLLAEX_LOGS_TARGET)
                    echo $CONTAINER_ID

                else 
                
                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME)

                fi

                for i in ${CONTAINER_ID[@]}; do

                    printf "\nContainer : $i\n"

                    if [[ $(docker logs $i --tail 10) ]]; then

                            docker logs $i --tail ${HOLLAEX_LOGS_TARGET_LINE:-100}

                    else 

                        echo "There are no logs for container : $i."

                    fi

                    printf "\n"

                done;
            
            }

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                show_docker_logs_simple &> "${HOLLAEX_LOGS_EXPORT_PATH}"

            else 

                show_docker_logs_simple
            
            fi

            printf "\n"
            echo "Displayed (Exported) last ${HOLLAEX_LOGS_TARGET_LINE:-100} lines of logs from container(s)."

            if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then

                echo "To see logs from specific container(s), Please run 'hollaex logs --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
                echo "For example, 'hollaex logs --target api --lines 20'."
            
            fi

            if [[ "$HOLLAEX_LOGS_EXPORT" == true ]]; then

                printf "\nYou can find the exported logs file at ${HOLLAEX_LOGS_EXPORT_PATH}.\n"
                exit 0;

            fi

        fi

    fi

    exit 0;
 

elif [[ "$1" == "version" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
        
    source $SCRIPTPATH/tools_generator.sh
     
    /bin/cat << EOF

:tt1   ;tti          LCC:1CC1         ,11tffttt            :tt;  ;tfi.tt1 ,,,
t@@8   f@@0  ,;ii;.  8@@;L@@f .:i1i:. ;@@@CLCGC;ii; ,iii.  t@@L,C@@L,.CCf,0@@;,
t@@8LLf0@@G,C@@G0@8L.0@@;L@@t.C80L0@8i:@@8tt;  :8@@1G@@1.  t@@0@@8:  ,8888@@@8G
t@@8CCC0@@CC@@L  G@@fG@@;L@@t,fCCfG@@L:@@@LLi    C@@@8,    t@@@C8@0: ,@@G.G@@,
t@@8   L@@G1@@0;;8@@i0@@;L@@fC@@Li0@@f:@@@iii11:i8@G@@C,   t@@L :0@@1,@@0 G@@1;
iGGL   tGGf ;LG00Gf: CGG:tGG1:LGGCLCG1:GGG0000fiGGL 1GGf.  iCC1  .LGG1CGf :LG0G,


HollaEx CLI : v$(cat $SCRIPTPATH/version).
HollaEx Kit : $(if [[ -f "$INIT_PATH_CHECK" ]]; then 
    echo "v$(cat $HOLLAEX_CLI_INIT_PATH/version)."
else
    echo -e "\033[91mNot in the Kit directory.\033[39m"
fi)

Made with <3 by bitHolla Inc.

EOF

else

    printf "\nInvalid Command. Please try it again.\n"
    print_usage;

    exit 1;

fi

exit 0;