#!/bin/bash 

SCRIPTPATH="$HOME/.hollaex-cli"

#### HollaEx CLI Settings ####

RUN_WITH_VERIFY=true 

LOCAL_DEPLOYMENT_MODE='all'

GENERATE_PASSWORDS=false

DOCKER_COMPOSE_NAME_PREFIX='local'

err_msg() { echo "$@" ;} >&2
err_msg_a() { err_msg "-a option argument required" ;}
err_msg_l() { err_msg "--long option argument required" ;}

function print_usage() {
/bin/cat << EOF

Usage : 
    hollaex [ init ] [ setup ] [ start ] [ restart ] [ stop ] [ build ] [ upgrade ] [ terminate ] [ web ] [ toolbox ] [ status ] [ logs ] [ version ] (--flags)

General Flags (Except for 'hollaex init', 'hollaex import'):
    --path, Manually pointing HollaEx Kit path. Should be always absolute path.
    --kube, Set HollaEx CLI to target Kubernetes. Make sure to setup your local kubectl before using it.
    --skip, Run command without user's double confirmation.

Options:
    init: Pull HollaEx Kit for your new exchange.

    setup: Setup the exchange for the first launch.
        --reconfigure, Reconfigure basic settings such as Server domain or Activation Code.
    
    import: Import settings files generated by using bitHolla Dashboard (dash.bitholla.com).
        --file, Path of file or directory where settings files are stored.
    
    login: Log in with bitHolla Dashboard account and select my Activation code. 

    logout: Log out and remove my bound Activation code on local.

    pull: Pull my Exchange configurations from bitHolla Dashboard to local.

    push: Push my local Exchange configurations to bitHolla Dashboard.

    start: Start the exchange which already been configured by 'hollaex setup' command.

    restart: Restart the existing exchange.
    
    stop: Stop the exchagne which already been running.

    build: Build the Docker image for running HollaEx Kit, includes user custom configurations.
    
    upgrade: Upgrade the exchange to new version.
        --version, Version number of HollaEx Core to upgrade.
        --user-image-registry, Specify Docker registry and version (tag) for the user HollaEx Core image.

    terminate: Terminate the existing exchange. THIS COMMAND WILL COMPLETELY REMOVE YOUR EXCHANGE.
      
    web: Run web client for the exchange.
        --setup, Setup the web client for the first launch.
        --start, Start the web client which already been configured.
        --stop, Stop the web client.
        --restart, Restart the web client.
        --build, Rebuild the web client docker image.
        --terminate, Terminate the web client. THIS COMMAND WILL COMPLETELY REMOVE YOUR WEB CLIENT.

    toolbox: Toolbox for advanced features which could be helpful for your exchange operations.
        --backup, Run the full backup with 'pg_dumpall' for exchange's PostgreSQL database.
        --flush_redis, Run the full flush of Redis stored data.
        --upgrade_api_only, Do zero-downtime rolling upgrade for exchange API contianers on Kubernetes.
        --add_coin, Add new currency on exchange.
        --remove_coin, Remove exisiting currency from exhcnage.
        --add_trading_pair, Add new trading pair on ehchange.
        --remove_trading_pair, Remove existing trading pair from exchange.
        --issue_ssl, Issue SSL certificate on local Nginx by using Let's Encrypt.
        --renew_ssl, Renew SSL certificate on local Nginx by using Let's Encrypt.
        --update_registry_secret, Update existing docker registry secret for Kubernetes.
        --set_activation_code, Set or update activation code for the exchange.
        --connect_database, Direct connection to PostgreSQL Database via postgresql-client.
        --connect_redis, Direct connection to Redis via redis-client.
        --connect_influxdb, Direct connection to InfluxDB via influx-client.
        
    status: Show the exchange server status.

    logs: Show overview of logs from the exchange server. 

    version: Print out current installed version of HollaEx CLI.

EOF
}

if [[ "$1" == 'dev' ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CODEBASE_PATH=$1
                echo "hollaex-core codebase : $HOLLAEX_CODEBASE_PATH."
                shift; continue
                ;;
            --command)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_COMMAND=$1
                echo "Your docker-compose command : $LOCAL_COMMAND."
                shift; continue
                ;;
            --database_init)
                LOCAL_DATABASE_INIT=true
                echo 'Local database initialization enabled.'
                shift; continue
                ;;
            --generate_passwords)
                GENERATE_PASSWORDS=true
                echo "Enable generating random password values. Make sure that you already removed existing values on config file."
                shift; continue
                ;;
            --test)
                LOCAL_CODE_TEST=true
                echo 'Local mocha code test mode enabled.'
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo 'Skipping the command confirmation.'
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    IS_DEVELOP=true

    if [[ "$HOLLAEX_CODEBASE_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-templates
        INIT_PATH_CHECK=$HOLLAEX_CODEBASE_PATH/.hollaex
        DOCKER_COMPOSE_NAME_PREFIX=$(basename "$HOLLAEX_CODEBASE_PATH")

    elif [[ ! "$HOLLAEX_CODEBASE_PATH" ]]; then

        CONFIG_FILE_PATH=$(pwd)/tools/hollaex-cli-settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/tools/hollaex-cli-templates
        INIT_PATH_CHECK=$(pwd)/.hollaex
        HOLLAEX_CODEBASE_PATH=$(pwd)
        DOCKER_COMPOSE_NAME_PREFIX=$(basename "$HOLLAEX_CODEBASE_PATH")

    fi

    echo $HOLLAEX_CODEBASE_PATH

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then
            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else
            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
    

        #Quit if necessary flags are missing
        if [[ ! "$LOCAL_COMMAND" ]] && [[ ! "$LOCAL_DATABASE_INIT" ]]; then
            echo "*********************************************"
            echo "Make sure to specify --command flag for dev commands"
            echo "*********************************************"
            print_usage;
            exit 1;

        fi

        # Running database jobs for local db.
        if [[ ! "$LOCAL_COMMAND" ]] && [[ "$LOCAL_DATABASE_INIT" == true ]]; then
        
            local_database_init dev;

            exit 0;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to run $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$GENERATE_PASSWORDS" == true ]]; then

            #Generating random values for passwords and update config file to contain it;
            update_random_values_to_config;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then

            generate_local_docker_compose_for_dev;
        fi

        generate_nginx_upstream;

        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "true" ]]; then
        
            generate_nginx_config_for_plugin;

        elif [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "false" ]]; then

            rm -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/plugins.conf

        fi

        docker-compose -f $HOLLAEX_CODEBASE_PATH/.${ENVIRONMENT_EXCHANGE_NAME}-docker-compose.yaml $LOCAL_COMMAND

        # Running database jobs for local db.
        if [[ "$LOCAL_DATABASE_INIT" == true ]]; then

            local_database_init dev;

        fi

        exit 0;

    fi


elif [[ "$1" == "init" ]]; then
    
    # while true; do
    #     [[ $# -eq 0 ]] && break
    #     case $1 in
    #         # --name)
    #         #     shift 
    #         #     case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
    #         #     ENVIRONMENT_EXCHANGE_NAME=$1
    #         #     echo "Name of your Exchange : $ENVIRONMENT_EXCHANGE_NAME."
    #         #     shift; continue
    #         #     ;;
    #         --standalone)
    #             shift 
    #             HOLLAEX_INIT_STANDALONE=true
    #             echo "HollaEx CLI will proceed to generate initialized directory without pulling HollaEx Kit repo."
    #             shift; continue
    #             ;;
    #     esac
    #     shift
    # done

    # #Quit if name of exchange is missing
    # if [[ ! "$ENVIRONMENT_EXCHANGE_NAME" ]]; then

    #     echo "You must specify the name of your Exchange! Use `--name` flag to pass name."
    #     print_usage;
    #     exit 1;

    # fi

    # if [[ ! "$HOLLAEX_INIT_STANDALONE" ]]; then

        echo "Pulling remote HollaEx Kit repo on $(pwd)"
        if command git clone https://github.com/bitholla/hollaex-kit.git; then
            
            HOLLAEX_CLI_INIT_PATH=$(pwd)/hollaex-kit
            CONFIG_FILE_PATH=$(pwd)/hollaex-kit/settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/hollaex-kit/templates
            INIT_PATH_CHECK=$(pwd)/hollaex-kit/.hollaex

            echo "HollaEx Kit is successfully initialized."
            echo "You can go to: $(pwd)/hollaex-kit and start setting up your exchange with 'hollaex setup' command."
            

        else 

            printf "\033[91mFailed to pull HollaEx Kit repository from GitHub. Please check your internet connectivity.\033[39m\n"
            exit 1;

        fi

    # else 

    #     HOLLAEX_CLI_INIT_PATH=$(pwd)/$ENVIRONMENT_EXCHANGE_NAME

    #     if [[ -d "$HOLLAEX_CLI_INIT_PATH" ]]; then

    #         echo "Init path exists! HollaEx CLI can't override exsiting exchange files."
    #         exit 1;
    #     fi

    #     echo "Initializing new Exchange - $HOLLAEX_CONFIGMAP_API_NAME on $HOLLAEX_CLI_INIT_PATH ..."

    #     mkdir $HOLLAEX_CLI_INIT_PATH

    #     cp -r $SCRIPTPATH/settings $HOLLAEX_CLI_INIT_PATH/settings
    #     cp -r $SCRIPTPATH/plugins $HOLLAEX_CLI_INIT_PATH/plugins
    #     cp -r $SCRIPTPATH/templates $HOLLAEX_CLI_INIT_PATH/templates
    #     touch $HOLLAEX_CLI_INIT_PATH/.hollaex
    #     echo "Initialized by using HollaEx CLI v$(cat $SCRIPTPATH/version)" >> $HOLLAEX_CLI_INIT_PATH/.hollaex

    #     # grep -v ENVIRONMENT_EXCHANGE_NAME= $HOLLAEX_CLI_INIT_PATH/settings/configmap > temp.init && mv temp.init $HOLLAEX_CLI_INIT_PATH/settings/configmap

    #     # (echo "ENVIRONMENT_EXCHANGE_NAME=$ENVIRONMENT_EXCHANGE_NAME" && cat $HOLLAEX_CLI_INIT_PATH/settings/configmap) > temp.init && mv temp.init $HOLLAEX_CLI_INIT_PATH/settings/configmap

    #     echo "All done!"
    #     echo "To run HollaEx CLI commands further, Please get into initialized path first to let HollaEx CLI reads settings."

    # fi
        
        exit 0;
    
elif [[ "$1" == "setup" ]]; then
    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --reconfigure)
                RECONFIGURE_BASIC_SETTINGS=true
                echo "HollaEx CLI will proceed to reconfigure your exchange's basic settings."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;
    
    # hollaex setup --reconfigure
    if [[ "$RECONFIGURE_BASIC_SETTINGS" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to reconfigure the exchange? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Ask for basic necessary settings
        launch_basic_settings_input;

        #hollaex upgrade --skip $(if [[ "$USE_KUBERNETES" ]]; then echo "--kube"; fi)

        echo "All done!"
        echo "Make sure to check your settings files been successfully updated by following your provided values."
        echo "You can run 'hollaex restart (--kube)' for applying the updated values on your exchange."

        exit 0;

    fi
    
    # Check that settings files are already configured.
    if [[ $HOLLAEX_SECRET_ACTIVATION_CODE ]]; then

        echo "HollaEx CLI detected the preconfigured values on your HollaEx Kit."
        echo "Do you want to proceed with this configurations? (Y/n)"
        read answer

        if [[ ! "$answer" = "${answer#[Nn]}" ]]; then
            
            launch_basic_settings_input;
        
        fi

    else

        launch_basic_settings_input;
    
    fi

    
    export ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$ENVIRONMENT_DOCKER_IMAGE_VERSION
    override_docker_image_version;
    
    build_user_hollaex_core;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        # launch_basic_settings_input;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes;
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mAlert: HollaEx CLI detected that $HOLLAEX_CONFIGMAP_API_NAME exchange exists on your remote Kubernetes environment.\033[39m\n"
            printf "\033[91mExchange setup can't be done for multiple times.\033[39m\n\n"
            printf "\033[91mIf you want to just update settings values, Please run 'hollaex setup --reconfigure' instead.\033[39m\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to launch $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        #Generating random values for passwords and update config file to contain it;
        update_random_values_to_config;


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap."
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret."
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress."
            generate_kubernetes_ingress;

        fi

        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress for custom plugins."
            generate_nginx_config_for_plugin;

        fi
        
        echo "Creating namespace on Kubernetes."
        kubectl create ns $ENVIRONMENT_EXCHANGE_NAME

        echo "Applying configmap on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml
        
        echo "Applying secret on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

            echo "Running Redis."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-redis --namespace $ENVIRONMENT_EXCHANGE_NAME --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)
        
        fi

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" == true ]]; then

            generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql
            echo "Running PostgreSQL DB."

            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-db --namespace $ENVIRONMENT_EXCHANGE_NAME --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set pvc.size="$ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_VOLUMESIZE" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_RUN_INFLUXDB" == true ]]; then

            if [[ "$ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR" ]]; then

                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR influxdb

            fi

            echo "Running InfluxDB."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-influxdb --namespace $ENVIRONMENT_EXCHANGE_NAME --set setCustomUser.enabled="true" --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set persistence.size="$ENVIRONMENT_KUBERNETES_INFLUXDB_VOLUMESIZE" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-influxdb.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb $(kubernetes_set_backend_image_target is_influxdb $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_VERSION)

        fi

        echo "Applying ingress on the namespace."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml
        
        create_kubernetes_docker_registry_secret;

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

        echo "Running $HOLLAEX_CONFIGMAP_API_NAME workload containers."

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api \
                     --wait \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --recreate-pods \
                     --set DEPLOYMENT_MODE="api" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set stable.replicaCount="$ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS" \
                     --set autoScaling.hpa.enable="true" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-stream \
                     --namespace $ENVIRONMENT_EXCHANGE_NAME \
                     --recreate-pods \
                     --set DEPLOYMENT_MODE="stream" \
                     --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" \
                     --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                     --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" \
                     --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" \
                     -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                     -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm_dynamic_trading_paris run;

        sleep 5;

        kubernetes_database_init launch;

        hollaex_setup_finalization;

        # hollaex_ascii_exchange_has_been_setup;

        echo "Shutting down the exchange..."
        hollaex stop --kube --skip
        
        echo "Finalizing the exchange setup..."
        sleep 5;

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"  
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if command docker ps | grep local_$ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "*********************************************"
            printf "\033[91mAlert: HollaEx CLI detected that $HOLLAEX_CONFIGMAP_API_NAME exchange exists on your machine.\033[39m\n"
            printf "\033[91mExchange setup can't be done for multiple times.\033[39m\n\n"
            printf "\033[91mIf you want to just update settings values, Please run 'hollaex setup --reconfigure' instead.\033[39m\n\n"
            echo "Exiting..."
            echo "*********************************************"
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi
        

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to run $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # #Generating random values for passwords and update config file to contain it;
        update_random_values_to_config;

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi
    
        
        # Generating docker-compose yaml for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream;
        
        fi

        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        # Generating nginx configurations for custom plugin
        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "true" ]]; then
        
            generate_nginx_config_for_plugin;

        elif [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "false" ]]; then

            rm -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/plugins.conf

        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then

             # Running database init
            RUN_WITH_VERIFY=false
            local_database_init start;

             # Restarting containers after database init jobs.
            echo "Restarting containers to apply database changes."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

        else 

            printf "\033[91mHollaEx CLI failed to launch containers. Please review your settings and try again.\033[39m\n"
            exit 1;
       
        fi
        
        hollaex_setup_finalization;

        # hollaex_ascii_exchange_has_been_setup;

        # echo "Finalizing the exchange setup..."
        # sleep 5;

        exit 0;

    fi

elif [[ "$1" == "import" ]]; then

    # while true; do
    #     [[ $# -eq 0 ]] && break
    #     case $1 in
    #         --file)
    #             shift 
    #             case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
    #             HOLLAEX_IMPORT_PATH=$1
    #             echo "Your file / directory path to import : $HOLLAEX_IMPORT_PATH."
    #             if [[ "$2" ]]; then
    #                 echo "Your second file / directory path to import : $HOLLAEX_IMPORT_PATH_2."
    #             fi
    #             shift; continue
    #             ;;
    #         --*) 
    #             err_msg "Invalid option: $1"
    #             print_usage;
    #             exit 1;
    #             ;;
    #     esac
    #     shift
    # done

    HOLLAEX_IMPORT_PATH_INPUT=$@
    IFS=' ' read -ra HOLLAEX_IMPORT_PATH <<< "$HOLLAEX_IMPORT_PATH_INPUT"    #Convert string to array

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! -d "$HOLLAEX_CLI_INIT_PATH/.old" ]]; then

        mkdir $HOLLAEX_CLI_INIT_PATH/.old

    fi

# Storing current CURRENCIES and PARIS
cat > $HOLLAEX_CLI_INIT_PATH/.old/old-currencies-and-pairs <<EOL

OLD_CURRENCIES=$(echo $HOLLAEX_CONFIGMAP_CURRENCIES)
OLD_PAIRS=$(echo $HOLLAEX_CONFIGMAP_PAIRS)

EOL

    rm $CONFIG_FILE_PATH

    for i in ${HOLLAEX_IMPORT_PATH[@]}; do

        if [[ -d "$i" ]]; then
            
            if command cp $i/* $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            else 

                IS_IMPORT_SUCCESS=false
            
            fi

        elif [[ -f "$i" ]]; then

            if command cp $i $IMPORT_FILE_PATH; then

                IS_IMPORT_SUCCESS=true
            
            else 

                IS_IMPORT_SUCCESS=false
            
            fi
        
        fi

    done;

    if [[ -d "$HOLLAEX_IMPORT_PATH" ]]; then
        
        if command cp $HOLLAEX_IMPORT_PATH/* $IMPORT_FILE_PATH; then

            IS_IMPORT_SUCCESS=true
        
        fi

    elif [[ -f "$HOLLAEX_IMPORT_PATH" ]]; then

        if command cp $HOLLAEX_IMPORT_PATH $IMPORT_FILE_PATH; then

            IS_IMPORT_SUCCESS=true
        
        fi
    
    fi

    if [[ "$IS_IMPORT_SUCCESS" == true ]]; then 

        printf "\033[92mYour settings files has been imported into your HollaEx Kit!\033[39m\n"
        echo "If you are trying to run a brand-new exchange, proceed to run 'hollaex setup'."
        echo "If you are already running the exchange, and trying to apply reconfigured files, run 'hollaex restart'."

    else 

        printf "\033[91m\nFailed to import your files into HollaEx Kit.\033[39m\n"
        echo "Please confirm that you passed the correct path of your settings files (or directory), and try again."

        exit 1;
    
    fi

elif [[ "$1" == "login" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done


    echo "bitHolla Account Email: "
    read email

    echo "bitHolla Account Password: "
    read -s password
    printf "\n"

    echo "OTP Code (If required. Leave it as blank if it's not.): "
    read otp

    BITHOLLA_ACCOUNT_TOKEN=$(curl -s -H "Content-Type: application/json" \
        --request POST \
        --data "{\"email\": \"${email}\", \"password\": \"${password}\", \"otp_code\": \"${otp}\", \"service\": \"cli\"}" \
        https://api.bitholla.com/v1/login \
        | jq -r '.token')

    if [[ ! "$BITHOLLA_ACCOUNT_TOKEN" ]] || [[ "$BITHOLLA_ACCOUNT_TOKEN" == "null" ]]; then

        printf "\033[91mFailed to authenticate on bitHolla Server with your passed credentials.\033[39m\n"
        echo -e "Please try it again.\n"
        exit 1;

    else 

        printf "\n\033[92mSuccessfully authenticated on bitHolla Server.\033[39m\n"
        echo "Info: Your authentication will be only available for 24 hours."

    fi

    BITHOLLA_USER_EXCHANGE_LIST=$(curl -s -H "Content-Type: application/json" -H "Authorization: Bearer $BITHOLLA_ACCOUNT_TOKEN"\
        --request GET \
        https://api.bitholla.com/v1/exchange \
       | jq '.')
    
    BITHOLLA_USER_EXCHANGE_COUNT=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r '.count')

    # Subtracting 1 from total count due to the array starts from 0, not from 1.
    BITHOLLA_USER_EXCHANGE_COUNT=$((BITHOLLA_USER_EXCHANGE_COUNT-1))

    echo -e "\n"

    for ((i=0;i<=BITHOLLA_USER_EXCHANGE_COUNT;i++)); do 

        echo "Exchange number : $i";

        echo "Name:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name");
        echo "Activation Code:" $(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code");
        echo -e "\n"

        EXCHANGE_NAME_TEMP=EXCHANGE_NAME_${i}
        EXCHANGE_ACTIVATION_CODE_TEMP=EXCHANGE_ACTIVATION_CODE_${i}

        export $(echo $EXCHANGE_NAME_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].name";);
        export $(echo $EXCHANGE_ACTIVATION_CODE_TEMP)=$(echo $BITHOLLA_USER_EXCHANGE_LIST | jq -r ".data[$i].activation_code";);

    done;

    echo "Please pick up the exchange number you want to bind."
    read answer
    
    printf "\n"
    SELECTED_EXCHANGE_NAME=EXCHANGE_NAME_${answer}
    SELECTED_EXCHANGE_ACTIVATION_CODE=EXCHANGE_ACTIVATION_CODE_${answer}

    echo "Selected Exchange name: ${!SELECTED_EXCHANGE_NAME}"
    echo "Selected Activation code: ${!SELECTED_EXCHANGE_ACTIVATION_CODE}"

    if command sed -i.bak "s/HOLLAEX_CONFIGMAP_API_NAME=.*/HOLLAEX_CONFIGMAP_API_NAME=${!SELECTED_EXCHANGE_NAME}/" $CONFIGMAP_FILE_PATH; then

        rm $CONFIGMAP_FILE_PATH.bak

        if command sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=${!SELECTED_EXCHANGE_ACTIVATION_CODE}/" $SECRET_FILE_PATH; then

            rm $SECRET_FILE_PATH.bak

            printf "\n\033[92mSuccessfully bound the selected exchange to HollaEx Kit.\033[39m\n"
        fi
    
    else

        printf "\033[91mFailed to bind selected exchange to HollaEx Kit.\033[39m\n"
        echo "Please review the error and try again."
        exit 1;

    fi

elif [[ "$1" == "logout" ]]; then

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        IMPORT_FILE_PATH=$(pwd)/settings
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        IMPORT_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_CONFIGMAP_API_NAME=" $i > /dev/null ; then

            export CONFIGMAP_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do

        if command grep -q "HOLLAEX_SECRET_ACTIVATION_CODE=" $i > /dev/null ; then

            export SECRET_FILE_PATH=$i

        fi

    done

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ ! "$HOLLAEX_CONFIGMAP_API_NAME" ]] || [[ ! "$HOLLAEX_SECRET_ACTIVATION_CODE" ]]; then

        printf "\033[91mFailed to read pre-bound Exchange name or Activation code.\033[39m\n"
        echo "'hollaex logout' works only after you successfully logged in."
        exit 1;
    
    fi

    printf "\nCurrent bound Exchange name: \033[92m$HOLLAEX_CONFIGMAP_API_NAME\033[39m\n\n"
    echo "This command will remove both Exchange name and Activation code from your local HollaEx Kit."
    echo "The rest of Exchagne configurations WILL NOT BE removed."
    echo "Are you sure you want to unbind this exchange from HollaEx Kit? (y/N)"
    read answer

    if [[ "$answer" = "${answer#[Yy]}" ]]; then
        echo "Exiting..."
        exit 0;
    fi

    if command sed -i.bak "s/HOLLAEX_CONFIGMAP_API_NAME=.*/HOLLAEX_CONFIGMAP_API_NAME=/" $CONFIGMAP_FILE_PATH; then

        rm $CONFIGMAP_FILE_PATH.bak

        if command sed -i.bak "s/HOLLAEX_SECRET_ACTIVATION_CODE=.*/HOLLAEX_SECRET_ACTIVATION_CODE=/" $SECRET_FILE_PATH; then

            rm $SECRET_FILE_PATH.bak

            printf "\n\033[92mSuccessfully removed the exchange data from HollaEx Kit.\033[39m\n"
        fi
    
    else

        printf "\033[91mFailed to remove exchange data from HollaEx Kit.\033[39m\n"
        echo "Please review the error and try again."
        exit 1;

    fi


elif [[ "$1" == "start" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --with_backends)
                WITH_BACKENDS=true
                echo "Creating backend components. Running backend components such as PostgreSQL or Redis together on this machine."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi


    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;


    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then


            echo "Are you sure you want to start (scale up) $HOLLAEX_CONFIGMAP_API_NAME v$ENVIRONMENT_DOCKER_IMAGE_VERSION ($HOLLAEX_CONFIGMAP_API_HOST) on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        #Generating and updating settings

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress for custom plugins"
            generate_nginx_config_for_plugin;

        fi
        

        echo "Applying configmap on the namespace"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

        echo "Applying secret on the namespace"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        # For scaling up exisitng Exchange on Kubernetes
        if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1; then

            echo "Scaling up containers on the cluster..."
            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=$ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            helm_dynamic_trading_paris scaleup;

            helm_dynamic_trading_paris run;

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME

            kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            echo "Applying Ingress rules..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            echo "All done!"
            echo "Containers successfully scaled up"

            hollaex_ascii_exchange_is_up;

            exit 0;

        else 

            echo "HollaEx CLI failed to detect existing exchange running on this Kubernetes."
            echo "Please review your settings files and targeted Kubernetes."

            exit 1;

        fi

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        # Exit HollaEx CLI If docker_compose 
        if [[ ! "$ENVIRONMENT_EXCHANGE_RUN_MODE" ]]; then

            echo "Your ENVIRONMENT_EXCHANGE_RUN_MODE value is missing! Please reconfirm your settings files."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;
        
        LOCAL_COMMAND="up -d"

        #Quit if necessary flags are missing
        if [[ ! "$LOCAL_COMMAND" ]]; then

            echo "Some necessary flags are missing! Please check agian your command."
            print_usage;
            exit 1;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to start $HOLLAEX_CONFIGMAP_API_NAME on your machine? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi  
        
        # Generating docker-compose yaml for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi
        
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream;
        
        fi

        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        # Generating nginx configurations for custom plugin
        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "true" ]]; then
        
            generate_nginx_config_for_plugin;

        elif [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "false" ]]; then

            rm -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/plugins.conf

        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml $LOCAL_COMMAND; then

            hollaex_ascii_exchange_is_up;
        
        else 

            printf "\033[91mFailed to start exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        exit 0;

    fi

elif [[ "$1" == "stop" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
           --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --mode)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                LOCAL_DEPLOYMENT_MODE=$1
                echo "Your DEPLOYMENT_MODE setup : $LOCAL_DEPLOYMENT_MODE."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done
    
    # Export hollaex-kit directory

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    #check_empty_values_on_settings

    if [[ "$USE_KUBERNETES" ]]; then
        

         #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop (scale down) $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
        kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        echo "Scaling down containers on the cluster..."
        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-api --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-server-stream --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        helm_dynamic_trading_paris scaledown;

        echo "Scaling down backend components..."

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-redis --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-db --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-influxdb --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        hollaex_ascii_exchange_has_been_stopped;

        # exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi 

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop $HOLLAEX_CONFIGMAP_API_NAME running on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            hollaex_ascii_exchange_has_been_stopped;

        else 

            printf "\033[91mFailed to stop exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        #exit 0;

    fi

elif [[ "$1" == "restart" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress for custom plugins"
            generate_nginx_config_for_plugin;

        fi

        echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
        kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Removing ingress for web client on the namespace"
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi

        echo "Applying latest configmap env on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

        echo "Applying latest secret on the cluster"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

        echo "Restarting all exchange containers on cluster"
        kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

        echo "Applying $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Applying ingress for web client on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi

        hollaex_ascii_exchange_is_up;

        exit 0;
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            printf "\033[91mHollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI.\033[39m\n"
            
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the restart!\033[39m\n"
            echo "Are you sure you want to restart $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then

            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Generating nginx upstream.conf for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream
        
        fi

        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "true" ]]; then

            generate_nginx_config_for_plugin;

        elif [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "false" ]]; then

            rm -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/plugins.conf

        fi
        
        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        # echo "Restarting containers to apply new changes..."
        # docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop
        # docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d
        
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml stop; then

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d --remove-orphans; then
                
                hollaex_ascii_exchange_is_up;

            else 

                printf "\033[91mFailed to restart exchange! Please review your settings and try again.\033[39m\n"
                exit 1;
            fi

        else 

            printf "\033[91mFailed to restart exchange! Please review your settings and try again.\033[39m\n"
            exit 1;
        
        fi

        exit 0;

    fi

elif [[ "$1" == "build" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE=$1
                echo "Target hollaex docker registry : $ENVIRONMENT_DOCKER_IMAGE_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$1
                echo "Target hollaex release version : v $ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    build_user_hollaex_core;


elif [[ "$1" == "upgrade" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --user-image-registry)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_USER_REGISTRY_OVERRIDE=$1
                echo "User HollaEx Core image registry and version : $ENVIRONMENT_USER_REGISTRY_OVERRIDE."
                shift; continue
                ;;
            --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$1
                echo "Target HollaEx Core release version : v $ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
             --no_image_build)
                NO_IMAGE_BUILD=true
                echo "Skipping the new image build."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # Override target docker image version if user passed it manually with flag.
    if [[ "$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE" ]]; then
        
        override_docker_image_version;
        export ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
        export ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
        
    fi

    # Override target docker registry if user passed it manually with flag.
    if [[ "$ENVIRONMENT_USER_REGISTRY_OVERRIDE" ]]; then
        
        override_user_docker_registry;
        
    fi

    # Update HollaEx CLI to latest if there is newer release available.
    update_hollaex_cli_to_latest;

    if [[ ! "$NO_IMAGE_BUILD" ]]; then

        # Building new HollaEx Core image based on passed (or specified) version.
        build_user_hollaex_core;
    
    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        #Creating kubernetes_config directory for generating config for Kubernetes.
        if [[ ! -d "$TEMPLATE_GENERATE_PATH/kubernetes/config" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/kubernetes/config;
        fi

        if [[ ! "$ENVIRONMENT_DOCKER_IMAGE_VERSION"  ]] || [[ ! "$ENVIRONMENT_EXCHANGE_NAME"  ]] ; then
            printf "\033[91mError: Please define exchange name and Docker image version on config file before running HollaEx CLI.\033[39m\n"
            print_usage
            exit 1;
        fi

        check_empty_values_on_settings;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"
            echo "Are you sure you want to upgrade $HOLLAEX_CONFIGMAP_API_NAME by using $ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY:$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION with $ENVIRONMENT_KUBERNETES_API_SERVER_REPLICAS api containers on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

            echo "Generating Kubernetes Configmap"
            generate_kubernetes_configmap;

        fi

        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

            echo "Generating Kubernetes Secret"
            generate_kubernetes_secret;

        fi


        if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_INGRESS_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress"
            generate_kubernetes_ingress;

        fi

        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == true ]]; then

            echo "Generating Kubernetes Ingress for custom plugins"
            generate_nginx_config_for_plugin;

        fi
        
        # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Applying latest configmap env on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

        echo "Applying latest secret on the cluster"
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then
        
            echo "Applying web client configmap on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-web-configmap.yaml

        fi

        # FOR GENERATING NODESELECTOR VALUES
        generate_nodeselector_values $ENVIRONMENT_KUBERNETES_EXCHANGE_NODESELECTOR hollaex

        echo "Upgrading $HOLLAEX_CONFIGMAP_API_NAME Pods on Kubernetes."
        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="api" --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" --set stable.replicaCount="2" --set autoScaling.hpa.enable="true" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

        helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-stream --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set DEPLOYMENT_MODE="stream" --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_REGISTRY" --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" --set envName="$ENVIRONMENT_EXCHANGE_NAME-env" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" --set podRestart_webhook_url="$ENVIRONMENT_KUBERNETES_RESTART_NOTIFICATION_WEBHOOK_URL" -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server
        
        helm_dynamic_trading_paris run;

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Running $HOLLAEX_CONFIGMAP_API_NAME web client container"
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web --namespace $ENVIRONMENT_EXCHANGE_NAME --recreate-pods --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" --set stable.replicaCount="1" --set autoScaling.hpa.enable="false" --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web

        fi
        
        # Running database job for Kubernetes
        kubernetes_database_init upgrade;

        echo "Restarting all containers to apply latest database changes..."
        kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

        echo "Waiting for the containers get fully ready..."
        sleep 15;

        echo "Applying $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
        kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        if [[ "$ENVIRONMENT_WEB_ENABLE" == true ]]; then

            echo "Applying ingress for web client on the namespace"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        fi


        hollaex_ascii_exchange_has_been_upgraded;

        exit 0;
    
    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx;
        fi

        if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
            mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
        fi

        check_empty_values_on_settings;

        if [[ "$RUN_WITH_VERIFY" == true ]]; then
            
            printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"
            echo "Are you sure you want to upgrade $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        # Override target docker image version If user passed it manually with flag.
        if [[ "$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE" ]]; then
            
            override_docker_image_version;
            ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
            
        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_ENV_ENABLE" == true ]]; then

            echo "Generating env file for docker"
            generate_local_env;

        fi

        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_YAML_ENABLE" == true ]]; then
            
            echo "Generating docker-compose file"
            generate_local_docker_compose

        fi

        # Generating nginx upstream.conf for exchange
        if [[ "$ENVIRONMENT_DOCKER_COMPOSE_GENERATE_NGINX_UPSTREAM" == true ]]; then

            echo "Generating Nginx upstream conf"
            generate_nginx_upstream
        
        fi
        
        if [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "true" ]]; then

            generate_nginx_config_for_plugin;

        elif [[ "$ENVIRONMENT_CUSTOM_PLUGINS_AUTOCONFIGURE_ENABLE" == "false" ]]; then

            rm -f $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/plugins.conf

        fi
        
        # Update nginx.conf to apply user own domains
        echo "Updating nginx conf file based on user settings"
        apply_nginx_user_defined_values;

        echo "Restarting containers to apply new changes..."
        if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d; then

            RUN_WITH_VERIFY=false
            local_database_init upgrade;

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart; then

                hollaex_ascii_exchange_has_been_upgraded;
            
            else 

                printf "\033[91mFailed to upgrade exchange! Please review your settings and try again.\033[39m\n"
                exit 1;

            fi

        else

            printf "\033[91mFailed to upgrade exchange! Please review your settings and try again.\033[39m\n"
            exit 1;

        fi

        exit 0;

    fi

elif [[ "$1" == "terminate" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on this cluster? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

         # Only tries to attempt remove ingress rules from Kubernetes if it exists.
        if ! command kubectl get ingress -n $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then
        
            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

        fi

        echo "Removing helm packages on the cluster."
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-server-api
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-server-stream
        
        helm_dynamic_trading_paris terminate;

        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-redis 
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-db
        helm del --purge $ENVIRONMENT_EXCHANGE_NAME-influxdb

        #Remove web server together if it exists on same namespace.
        if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web; then
            
            helm del --purge $ENVIRONMENT_EXCHANGE_NAME-web

        fi

        echo "Removing $HOLLAEX_CONFIGMAP_API_NAME namespace."
        kubectl delete ns $ENVIRONMENT_EXCHANGE_NAME

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated. If there's an issue, please review the logs and try it again."

        exit 0;

    fi

    if [[ ! "$USE_KUBERNETES" ]]; then

        # Checking docker-compose is installed on this machine.
        if command docker-compose version > /dev/null 2>&1; then

            echo "*********************************************"
            echo "docker-compose detected"
            echo "version: $(docker-compose version)"
            echo "*********************************************"

        else

            echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
            exit 1;

        fi

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to terminate $HOLLAEX_CONFIGMAP_API_NAME on your machine? (y/N)"

            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml down --remove-orphans -v

        # Remove web server together if it exists.
        if [[ -f "$TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml" ]] ; then

            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down 
        fi

        echo "$HOLLAEX_CONFIGMAP_API_NAME ($HOLLAEX_CONFIGMAP_API_HOST) has been successfully terminated. If there's an issue, please review the logs and try it again."

        exit 0;

    fi

elif [[ "$1" == "web" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --setup)
                WEB_CLIENT_SETUP=true
                echo "Setup the web client."
                shift; continue
                ;;
            --start)
                WEB_CLIENT_START=true
                echo "Start the web client."
                shift; continue
                ;;
            --stop)
                WEB_CLIENT_STOP=true
                echo "Stop the web client."
                shift; continue
                ;;
            --restart)
                WEB_CLIENT_RESTART=true
                echo "Restart the web client."
                shift; continue
                ;;
            --build)
                WEB_CLIENT_REBUILD=true
                echo "Rebuild the web client."
                shift; continue
                ;;
            --terminate)
                WEB_CLIENT_TERMINATE=true
                echo "Terminate the web client."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;
    
    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # Setting web operation enabled command to true.
    ENVIRONMENT_WEB_ENABLE=true

    # hollaex web --setup
    if [[ "$WEB_CLIENT_SETUP" ]]; then

        basic_settings_for_web_client_input;

        build_user_hollaex_web;

        echo "Values are successfully set!"
        echo "Use 'hollaex web --start' to start the Web Server."

        exit 0;

    fi

    if [[ "$WEB_CLIENT_START" ]]; then

        if command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY > /dev/null && command docker images | grep $ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION > /dev/null; then

            echo "Pre-built image for web server has been detected on your system."
            echo "Do you want to proceed with this pre-built image? (Y/n)"
            read answer 

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                build_user_hollaex_web;
            
            else 

                echo "Proceeding..."
            
            fi
        
        else 

            echo "Building the web server image..."
            build_user_hollaex_web;

        fi

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to start web server for the exchange on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web ingress rules for Kubernetes."
            generate_kubernetes_ingress_for_web;

            echo "Applying ingress rules for web on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            if command helm ls | grep $ENVIRONMENT_EXCHANGE_NAME-web; then

                echo "Starting web server..."
                kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=1 --namespace $ENVIRONMENT_EXCHANGE_NAME
            
            else 

                if ! command kubectl get secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME > /dev/null; then

                    create_kubernetes_docker_registry_secret;
                
                fi

                echo "Running $HOLLAEX_CONFIGMAP_API_NAME web server."
                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-web \
                            --namespace $ENVIRONMENT_EXCHANGE_NAME \
                            --recreate-pods \
                            --set imageRegistry="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_REGISTRY" \
                            --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_WEB_IMAGE_VERSION" \
                            --set stable.replicaCount="1" \
                            --set autoScaling.hpa.enable="false" \
                            --set envName="$ENVIRONMENT_EXCHANGE_NAME-web-env" \
                            -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-hollaex.yaml \
                            -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web/values.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-web

            hollaex_ascii_web_server_is_up;
        
        fi


        elif [[ ! "$USE_KUBERNETES" ]]; then

            # Checking docker-compose is installed on this machine.
            if command docker-compose version > /dev/null 2>&1; then
                
                echo "*********************************************"
                echo "docker-compose detected"
                echo "version: $(docker-compose version)"
                echo "*********************************************"

            else

                echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
                exit 1;

            fi

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to start web client for the exchange on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            #Generating nginx conf.d folder
            if [[ ! -d "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d" ]]; then
                mkdir $TEMPLATE_GENERATE_PATH/local/nginx/conf.d;
            fi

            echo "Generating docker-compose file for Web Client"
            generate_local_docker_compose_for_web

            echo "Generating .env for Web Client"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                echo "Generating Nginx conf for Web Client"
                generate_hollaex_web_local_nginx_conf

            fi

            echo "Generating Nginx Upstream for Web Client"
            generate_nginx_upstream_for_web

            echo "Updating nginx conf file based on user settings"
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d; then

                if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " " > /dev/null 2>&1; then 

                    echo "Reloading Nginx..."
                    docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload
                    
                    hollaex_ascii_web_server_is_up;
                
                else

                    printf "\033[91mFailed to reload Nginx. Did you start the exchange server?\033[39m\n"
                
                fi

            else 

                echo "HollaEx CLI failed to start the web client. Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_STOP" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Are you sure you want to stop web server for the exchange on this cluster? (Y/n)"

            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Removing ingress rules for web on the namespace."
        kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

        echo "Stopping web server..."
        kubectl scale deployment/$ENVIRONMENT_EXCHANGE_NAME-web --replicas=0 --namespace $ENVIRONMENT_EXCHANGE_NAME

        echo "Successfully stopped web client."
        echo "To bring it up, Use 'hollaex web --start --kube' command".
    
        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to stop web client for the exchange on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating docker-compose file for Web Client"
            generate_local_docker_compose_for_web

            echo "Cleaning up Nginx Conf for Web"
            cat /dev/null > $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf
            cat /dev/null > $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/upstream-web.conf

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then

                if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " " > /dev/null 2>&1; then 

                    echo "Reloading Nginx..."
                    docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

                    echo "Web is down!"
                    echo "Web container has been successfully stopped".
                
                else

                    printf "\033[91mFailed to reload Nginx. Did you start the exchange server?\033[39m\n"
                
                fi

                echo "Successfully stopped web client."
                echo "To bring it up, Use 'hollaex web --start' command".

            else 

                echo "HollaEx CLI failed to stop the web client. Please review your settings and try again."
                exit 1;
            
            fi

        fi

        exit 0;
        
    fi

    if [[ "$WEB_CLIENT_RESTART" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating web ingress rules for Kubernetes."
            generate_kubernetes_ingress_for_web;

            echo "Applying ingress rules for web on the namespace."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            echo "Restarting web server..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-web

            echo "Web server has been restarted!"
            echo "Web server will be reachable at $HOLLAEX_CONFIGMAP_DOMAIN very soon".

        elif [[ ! "$USE_KUBERNETES" ]]; then

            # Checking docker-compose is installed on this machine.
            if command docker-compose version > /dev/null 2>&1; then

                echo "*********************************************"
                echo "docker-compose detected"
                echo "version: $(docker-compose version)"
                echo "*********************************************"

            else

                echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
                exit 1;

            fi

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to restart web client for the exchange on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Generating docker-compose file for Web Client"
            generate_local_docker_compose_for_web

            echo "Generating .env for Web Client"
            generate_hollaex_web_local_env

            if [[ ! -f "$TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf" ]]; then

                echo "Generating Nginx conf for Web Client"
                generate_hollaex_web_local_nginx_conf

            fi

            echo "Updating nginx conf file based on user settings"
            apply_nginx_user_defined_values

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client stop; then
                
                docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client up -d

                if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " " > /dev/null 2>&1; then 

                    echo "Reloading Nginx..."
                    docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

                    echo "Web is up!"
                    echo "Web is now reachable both from $HOLLAEX_CONFIGMAP_DOMAIN and localhost:8080".
                
                else

                    printf "\033[91mFailed to reload Nginx. Did you start the exchange server?\033[39m\n"
                
                fi

            else 

                echo "HollaEx CLI failed to restart the web client. Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

    if [[ "$WEB_CLIENT_REBUILD" ]];  then
    
        build_user_hollaex_web;

        exit 0;

    fi

    if [[ "$WEB_CLIENT_TERMINATE" ]]; then

        if [[ "$USE_KUBERNETES" ]]; then

            #Checking Kubernetes dependencies
            check_kubernetes_dependencies;

            echo "*********************************************"
            #Verify remote Kubernetes cluster is correct.
            echo "Verifying current KUBECONFIG on the machine"
            kubectl get nodes
            echo "*********************************************"

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate web client for the exchange on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Terminating the web server on Kubernetes..."

            echo "Removing $HOLLAEX_CONFIGMAP_API_NAME ingress rule on the cluster."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress-web.yaml

            echo "Removing web server..."
            helm del --purge $ENVIRONMENT_EXCHANGE_NAME-web

            echo "Web is down!"
            echo "Web server has been successfully removed."

            exit 0;
                

        elif [[ ! "$USE_KUBERNETES" ]]; then

            # Checking docker-compose is installed on this machine.
            if command docker-compose version > /dev/null 2>&1; then
                
                echo "*********************************************"
                echo "docker-compose detected"
                echo "version: $(docker-compose version)"
                echo "*********************************************"

            else

                echo "HollaEx CLI failed to detect docker-compose installed on this machine. Please install it before running HollaEx CLI."
                exit 1;

            fi

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to terminate web client for the exchange on this machine? (y/N)"
                echo "This can't be undo."

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            if command docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose-web.yaml -p client down --remove-orphans; then

                if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " " > /dev/null 2>&1; then 

                    echo "Cleaning up Nginx Conf for Web"
                    cat /dev/null > $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/web.conf
                    cat /dev/null > $TEMPLATE_GENERATE_PATH/local/nginx/conf.d/upstream-web.conf

                    echo "Reloading Nginx..."
                    docker exec $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") nginx -s reload

                    echo "Web is down!"
                    echo "Web container has been successfully removed."
                
                else

                    printf "\033[91mFailed to reload Nginx. Did you start the exchange server?\033[39m\n"
                
                fi

                echo "Web has been successfully terminated."

            else 

                echo "HollaEx CLI failed to terminate the web client. Please review your settings and try again."
                exit 1;
            
            fi

            exit 0;

        fi
    fi

elif [[ "$1" == "toolbox" ]]; then

    while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --dev)
                IS_DEVELOP=true
                echo "HollaEx CLI is configured as dev mode for development purpose."
                shift; continue
                ;;
            --upgrade_backends)
                UPGRADE_BACKENDS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will upgrade your backends (PostgreSQL, Redis, InfluxDB) based on your settings files value."
                shift; continue
                ;;
            --backup)
                BACKUP_POSTGRESQL=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run PostgreSQL database dump on your initialized exchange folder."
                shift; continue
                ;;
            --flush_redis)
                FLUSH_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will run full flush of Redis stored data. This could be helpful in certain situation If the exchange doesnt work properly."
                shift; continue
                ;;
            --upgrade_api_only)
                UPGRADE_API_ONLY=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will rolling-upgrade API containers only for Kubernetes."
                shift; continue
                ;;
            # Version flag for --upgrade_api_only (rolling upgrade) for Kubernetes deployment.
             --version)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE=$1
                echo "Target HollaEx release version for API rolling upgrade : v $ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE."
                shift; continue
                ;;
            --add_coin)
                ADD_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new coin on your existing exchange."
                shift; continue
                ;;
            --add_trading_pair)
                ADD_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to add new trading pair on your existing exchange."
                shift; continue
                ;;
            --remove_coin)
                REMOVE_COIN=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove coin on your existing exchange."
                shift; continue
                ;;
            --remove_trading_pair)
                REMOVE_TRADING_PAIR=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to remove trading pair on your existing exchange."
                shift; continue
                ;;
            --is_hollaex_setup)
                IS_HOLLAEX_SETUP=true
                shift; continue
                ;;
            # --reconfigure_basic_settings)
            #     RECONFIGURE_BASIC_SETTINGS=true
            #     TOOLBOX_ENABLE=true
            #     echo "HollaEx CLI will proceed to reconfigure your exchange's basic settings."
            #     shift; continue
            #     ;;
            # --reactivate_exchange)
            #     REACTIVATE_EXCHANGE=true
            #     TOOLBOX_ENABLE=true
            #     echo "HollaEx CLI will proceed to reactivate your exchange with new activate information."
            #     shift; continue
            #     ;;
            --issue_ssl)
                ISSUE_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to issue SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
            --renew_ssl)
                RENEW_SSL_CERT=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will proceed to renew SSL certificate by using Let's Encrypt for local exchange."
                shift; continue
                ;;
             --update_registry_secret)
                UPDATE_REGISTRY_SECRET=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your docker image registry secret for Kubernetes."
                shift; continue
                ;;
            --set_activation_code)
                SET_ACTIVATION_CODE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will update your activation code for the exchange."
                shift; continue
                ;;
             --connect_database)
                CONNECT_DATABASE=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via postgresql-client."
                shift; continue
                ;;
             --connect_redis)
                CONNECT_REDIS=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via redis-client."
                shift; continue
                ;;
             --connect_influxdb)
                CONNECT_INFLUXDB=true
                TOOLBOX_ENABLE=true
                echo "HollaEx CLI will open a direct connection to your PostgreSQL database via influx-client."
                shift; continue
                ;;
            --skip)
                RUN_WITH_VERIFY=false
                echo "Skipping the command confirmation."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
    done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    # PATH overriding for develop    
    if [[ "$IS_DEVELOP" ]]; then

        if [[ "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$HOLLAEX_CODEBASE_PATH/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$HOLLAEX_CODEBASE_PATH/.hollaex
            DOCKER_COMPOSE_NAME_PREFIX=$(basename "$HOLLAEX_CODEBASE_PATH")

        elif [[ ! "$HOLLAEX_CODEBASE_PATH" ]]; then

            CONFIG_FILE_PATH=$(pwd)/tools/hollaex-cli-settings/*
            TEMPLATE_GENERATE_PATH=$(pwd)/tools/hollaex-cli-templates
            INIT_PATH_CHECK=$(pwd)/.hollaex
            HOLLAEX_CODEBASE_PATH=$(pwd)
            DOCKER_COMPOSE_NAME_PREFIX=$(basename "$HOLLAEX_CODEBASE_PATH")

        fi

    fi
    
    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi

    if [[ ! "$TOOLBOX_ENABLE" ]]; then
    
        print_usage;
        echo "No features are enabled for toolbox. Please recheck the command."
        exit 1;

    fi

    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done;

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    # --version flag for --upgrade_api_only
    # Override target docker image version if user passed it manually with flag.
    if [[ "$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE" ]]; then
        
        override_docker_image_version;
        export ENVIRONMENT_DOCKER_IMAGE_VERSION=$ENVIRONMENT_DOCKER_IMAGE_VERSION_OVERRIDE
        
    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        echo "*********************************************"
        #Verify remote Kubernetes cluster is correct.
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

    fi

    # Features
    if [[ "$UPGRADE_BACKENDS" ]]; then 

        printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"

        echo "All workload containers will be restarted once the upgrade process is done."
    
        if [[ "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Deleting Ingress rules for the exchange..."
            kubectl delete -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            
            if [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

                echo "Upgrading PostgreSQL DB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_POSTGRESQL_DB_NODESELECTOR postgresql

                helm upgrade $ENVIRONMENT_EXCHANGE_NAME-db --recreate-pods --namespace $ENVIRONMENT_EXCHANGE_NAME --set imageRegistry="${ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY}" --set dockerTag="${ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION}" --set pvc.create=true --set pvc.name="$ENVIRONMENT_EXCHANGE_NAME-postgres-volume" --set secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-postgresql.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-postgres $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_POSTGRESQL_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_POSTGRESQL_DB_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_POSTGRESQL_DB_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_REDIS" ]]; then

                echo "Upgrading Redis"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_REDIS_NODESELECTOR redis

                helm upgrade $ENVIRONMENT_EXCHANGE_NAME-redis --recreate-pods --namespace $ENVIRONMENT_EXCHANGE_NAME --set setAuth.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret" $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-redis $(kubernetes_set_backend_image_target $ENVIRONMENT_DOCKER_IMAGE_REDIS_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_REDIS_VERSION) $(set_nodeport_access $ENVIRONMENT_KUBERNETES_ALLOW_EXTERNAL_REDIS_ACCESS $ENVIRONMENT_KUBERNETES_EXTERNAL_REDIS_ACCESS_PORT)

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_RUN_INFLUXDB" ]]; then
                
                echo "Upgrading InfluxDB"
                generate_nodeselector_values $ENVIRONMENT_KUBERNETES_INFLUXDB_NODESELECTOR influxdb

                helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-influxdb --recreate-pods --namespace $ENVIRONMENT_EXCHANGE_NAME --set setCustomUser.enabled="true" --set setCustomUser.secretName="$ENVIRONMENT_EXCHANGE_NAME-secret"  -f $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb/values.yaml -f $TEMPLATE_GENERATE_PATH/kubernetes/config/nodeSelector-influxdb.yaml $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-influxdb $(kubernetes_set_backend_image_target is_influxdb $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_REGISTRY $ENVIRONMENT_DOCKER_IMAGE_INFLUXDB_VERSION)

            fi

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            sleep 10;

            echo "Applying Ingress rules for the exchange..."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-ingress.yaml

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to upgrade backends (PostgreSQL, Redis, InfluxDB) to latest compatible on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "All workload containers will be restarted once the upgrade process is done."

            echo "Regenerating docker-compose file..."
            generate_local_docker_compose $ENVIRONMENT_EXCHANGE_RUN_MODE

            echo "Restarting containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml up -d

            exit 0;

        fi

    elif [[ "$BACKUP_POSTGRESQL" ]]; then

        # Check pg_dump is available on your local
        if command pg_dumpall --version > /dev/null 2>&1; then

            echo "pg_dump detected on your machine!"
            pg_dumpall --version

        else 

            echo "HollaEx CLI failed to detect pg_dump on your machine"
            echo "Please make sure that you already installed pg_dump"

            exit 1;

        fi 

        if [[ ! -d $HOLLAEX_CLI_INIT_PATH/backups ]]; then

            echo "Creating '/backups' folder on HollaEx Kit directory"
            mkdir $HOLLAEX_CLI_INIT_PATH/backups

        fi

        if [[ "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_KUBERNETES_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this cluster? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will open proxy tunnel between your machine and remote proxy with kubectl proxy."

            echo "Opening local proxy on 5432 port of your machine..."
            kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &

            echo "Waiting for the proxy tunnel get fully ready..."
            sleep 10;
            
            echo "Running pg_dumpall..."
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost

            pg_dumpall > $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved as $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump"

            echo "Killing the opened proxy tunnel..."
            kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

            exit 0;

        fi

        if [[ ! "$USE_KUBERNETES" ]] && [[ "$ENVIRONMENT_DOCKER_COMPOSE_RUN_POSTGRESQL_DB" ]]; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run full PostgreSQL database backup (pg_dumpall) on this machine? (Y/n)"

                read answer

                if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "HollaEx CLI will backup your local PostgreSQL DB."

            echo "Running pg_dumpall..."
            
            export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
            export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
            export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
            export PGHOST=localhost
            pg_dumpall > $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump
            
            unset PGUSER
            unset PGPASSWORD
            unset PGDATABASE
            unset PGHOST

            echo "Dump data is saved as $HOLLAEX_CLI_INIT_PATH/backups/$HOLLAEX_CONFIGMAP_API_NAME-db-$(date +%y%m%d%H%M).dump"

            exit 0;

        fi
        
    elif [[ "$FLUSH_REDIS" ]]; then

        printf "\033[93mWarning: Exchange service will be unavailable during the upgrade!\033[39m\n"

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to run flush Redis data on this cluster? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Flushing Redis..."
            kubectl exec --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-server-api" -o name | sed 's/pod\///' | head -n 1) -- node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            kubectl delete pods --namespace $ENVIRONMENT_EXCHANGE_NAME -l role=$ENVIRONMENT_EXCHANGE_NAME

            exit 0;

        elif [[ ! "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to to run flush Redis data on this machine? (y/N)"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            echo "Shutting down Nginx to block exchange external access"
            docker stop $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ")

            IFS=',' read -ra CONTAINER_PREFIX <<< "-${ENVIRONMENT_EXCHANGE_RUN_MODE}"
            
            echo "Flushing Redis..."
            docker exec ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/flushRedis.js

            echo "Restarting all workload containers..."
            docker-compose -f $TEMPLATE_GENERATE_PATH/local/$ENVIRONMENT_EXCHANGE_NAME-docker-compose.yaml restart

            sleep 10;

            exit 0;
        fi
        
    elif [[ "$UPGRADE_API_ONLY" ]]; then

        if [[ "$USE_KUBERNETES" ]] ; then

            if [[ "$RUN_WITH_VERIFY" == true ]]; then

                echo "Are you sure you want to do rolling upgrade for $HOLLAEX_CONFIGMAP_API_NAME api pods to v$ENVIRONMENT_DOCKER_IMAGE_VERSION on this cluster? (y/N)"
                echo "Configmap values would be updated either while on the rolling upgrade"

                read answer

                if [[ "$answer" = "${answer#[Yy]}" ]]; then
                    echo "Exiting..."
                    exit 0;
                fi

            fi

            if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_CONFIGMAP_ENABLE" == true ]]; then

                echo "Generating Kubernetes Configmap"
                generate_kubernetes_configmap;

            fi

             if [[ "$ENVIRONMENT_KUBERNETES_GENERATE_SECRET_ENABLE" == true ]]; then

                echo "Generating Kubernetes Secret"
                generate_kubernetes_secret;

            fi

            echo "Applying latest configmap env on the cluster."
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-configmap.yaml

            echo "Applying latest secret on the cluster"
            kubectl apply -f $TEMPLATE_GENERATE_PATH/kubernetes/config/$ENVIRONMENT_EXCHANGE_NAME-secret.yaml

            echo "Upgrading $HOLLAEX_CONFIGMAP_API_NAME API pods only on Kubernetes."
            helm upgrade --install $ENVIRONMENT_EXCHANGE_NAME-server-api \
                        --namespace $ENVIRONMENT_EXCHANGE_NAME \
                        --reuse-values \
                        --set dockerTag="$ENVIRONMENT_USER_HOLLAEX_CORE_IMAGE_VERSION" \
                        $SCRIPTPATH/kubernetes/helm-chart/bitholla-hollaex-server

            echo "Rolling upgrade process has been finished."
            echo "It would take few minutes to Kubernetes replace api pods to new version completely. Please check the status constantly."
            
            exit 0;
            
        
        elif [[ ! "$USE_KUBERNETES" ]] ; then

            echo "HollaEx CLI only supports rolling-upgrade for api contianers on Kubernets environment."
            echo "Please use --kube flag to point Kubernetes."

            exit 1;

        fi


    elif [[ "$ADD_COIN" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom currencies on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_CURRENCIES_TO_ADD <<< "$HOLLAEX_CONFIGMAP_CURRENCIES"

            for j in ${CUSTOM_CURRENCIES_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export COIN_SYMBOL=$j
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_COIN_$(echo $j | tr a-z A-Z)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mCoin configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_coin_exec;
                    
                    else 

                        printf "\033[91mError: Coin configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."

                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "CURRENCIES=${HOLLAEX_CONFIGMAP_CURRENCIES}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi

        else 

            printf "\033[93mWarning: Adding new coin requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_coin_input;

            add_coin_exec;
        
        fi
        
    elif [[ "$REMOVE_COIN" ]]; then

        printf "\033[93mWarning: Removing new coin requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"
        
        remove_coin_input;

        remove_coin_exec;
    
    elif [[ "$ADD_TRADING_PAIR" ]]; then

        if [[ "$IS_HOLLAEX_SETUP" ]]; then

            echo "Adding user custom trading pairs on the exchange..."

            for i in ${CONFIG_FILE_PATH[@]}; do

                if command grep -q "ENVIRONMENT_USER_HOLLAEX_CORE_" $i > /dev/null ; then

                    export CONFIGMAP_FILE_PATH=$i

                fi

            done

            IFS=',' read -ra CUSTOM_PAIRS_TO_ADD <<< "$HOLLAEX_CONFIGMAP_PAIRS"

            for j in ${CUSTOM_PAIRS_TO_ADD[@]}; do

                if command grep -q $j $CONFIGMAP_FILE_PATH > /dev/null; then

                    export PAIR_NAME=$j
                    export PAIR_BASE=$(echo $j | cut -f1 -d "-")
                    export PAIR_2=$(echo $j | cut -f2 -d "-")
                    export PAIR_PREFIX=$(echo $PAIR_BASE | tr a-z A-Z)_$(echo $PAIR_2 | tr a-z A-Z)
     
                    export VALUE_IMPORTED_FROM_CONFIGMAP=true

                    if command grep -q "ENVIRONMENT_ADD_PAIR_$(echo $PAIR_PREFIX)_" $CONFIGMAP_FILE_PATH > /dev/null ; then

                        printf "\033[92mTrading pair configurations for $j has been detected at user's configmap file!\033[39m\n"
                        echo "Proceeding to add..."

                        add_pair_exec;
                    
                    else 

                        printf "\033[91mError: Trading pair configurations for $j doesn't exists at user's configmap file.\033[39m\n"
                        echo "Skipping to add..."
                    
                    fi
                
                fi
            
            done

            if [[ "$USE_KUBERNETES" ]]; then

                kubernetes_database_init upgrade;

            else 

                echo "Running database triggers"
                docker exec --env "PAIRS=${HOLLAEX_CONFIGMAP_PAIRS}" ${DOCKER_COMPOSE_NAME_PREFIX}_${ENVIRONMENT_EXCHANGE_NAME}-server${CONTAINER_PREFIX[0]}_1 node tools/dbs/runTriggers.js > /dev/null;
            
            fi

        else 

            printf "\033[93mWarning: Adding new pair requires full restart of the exchange!\033[39m\n"
            echo "Please double confirm that you are good to proceed"
            
            add_pair_input;

            add_pair_exec;
        
        fi

    elif [[ "$REMOVE_TRADING_PAIR" ]]; then

        printf "\033[93mWarning: Removing new pair requires full restart of the exchange!\033[39m\n"
        echo "Please double confirm that you are good to proceed"
        
        remove_pair_input;

        remove_pair_exec;
    
    # elif [[ "$RECONFIGURE_BASIC_SETTINGS" ]]; then

    #     # Ask for basic necessary settings
    #     launch_basic_settings_input;

    #     echo "Make sure to check your settings files been successfully updated by following your provided values."
    #     echo "Once it's all good, then you can proceed to actually update your exchange by using 'hollaex upgrade' command."
    #     echo "If you also updated activation code for the exchange, make sure to run 'hollaex toolbox --reactivate_exchange' command after 'hollaex upgrade'."

    # elif [[ "$REACTIVATE_EXCHANGE" ]]; then

    #     reactivate_exchange;
    

    elif [[ "$ISSUE_SSL_CERT" ]]; then
        
        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to issue SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi
        fi

        echo "Issuing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot --nginx; then
            
            echo "SSL cert has been successfully set."
            echo "All Let's encrypt related files can be found at ./templates/local/letsencrypt."

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
 
        
    
    elif [[ "$RENEW_SSL_CERT" ]]; then

        if [[ "$RUN_WITH_VERIFY" == true ]]; then

            echo "Would you like to continue to renew SSL cert through Let's Encrypt? (y/N)"
            read answer

            if [[ "$answer" = "${answer#[Yy]}" ]]; then
                echo "Exiting..."
                exit 0;
            fi

        fi

        echo "Renewing SSL..."

        if command docker exec -it $(docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-nginx | cut -f1 -d " ") certbot renew; then
        
            echo "SSL cert has been successfully renewed."
            echo "All Let's encrypt related files can be found at ./templates/local/letsencrypt."

        else 

            printf "\033[91mFailed to issue SSL certificate by using Certbot. Please confirm your settings and try again.\033[39m\n"
            exit 1;

        fi
      

    elif [[ "$UPDATE_REGISTRY_SECRET" ]]; then

        if [[ ! "$USE_KUBERNETES" ]]; then 

            echo "Warning: Docker registry secret update is only available for Kubernetes."
            echo "Please use 'hollaex toolbox --update_registry_secret --kube' command instead."
            exit 1;

        fi

        check_kubernetes_dependencies;
        
        echo "*********************************************"
        echo "Verifying current KUBECONFIG on the machine"
        kubectl get nodes
        echo "*********************************************"

        echo "Are you sure that you want to update your existing Docker registry secret at this Kubernets cluster? (y/N)"
        read answer 

        if [[ "$answer" = "${answer#[Yy]}" ]] ;then
            echo "Exiting..."
            exit 0;
        fi

        echo "Removing the current Docker registry secret at $ENVIRONMENT_EXCHANGE_NAME namespace."
        kubectl delete secret docker-registry-secret --namespace $ENVIRONMENT_EXCHANGE_NAME

         if [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD" ]] && [[ "$ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL" ]]; then

            echo "Docker registry credentials are detected at your configmap file."

            echo "*********************************************"
            echo "Docker Registry Host: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_HOST"
            echo "Docker Registry Email: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_EMAIL"
            echo "Docker Registery Username: $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_USERNAME"
            echo "Docker Registry Password: $(echo ${ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD//?/}$(echo $ENVIRONMENT_KUBERNETES_DOCKER_REGISTRY_PASSWORD | grep -o '....$'))"
            echo "*********************************************"
            echo "You can either proceed with this values, or set it again manually by yourself."
            echo "Do you want to proceed with this values? (Y/n)"
            read answer

            if [[ ! "$answer" = "${answer#[Nn]}" ]] ;then

                echo "Proceeding to a from to re-fill up the credentials."
                MANUAL_DOCKER_REGISTRY_SECRET_UPDATE=true

            fi
        
        fi

        create_kubernetes_docker_registry_secret;
    
    elif [[ "$SET_ACTIVATION_CODE" ]]; then
        
        if [[ "$USE_KUBERNETES" ]]; then 

            # check_kubernetes_dependencies;
        
            # echo "*********************************************"
            # echo "Verifying current KUBECONFIG on the machine"
            # kubectl get nodes
            # echo "*********************************************"

            echo "Are you sure that you want to update your activation code for the exchange on this Kubernets cluster? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart --kube' to fully apply it."


        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            echo "Are you sure that you want to update your activation code for the exchange on this machine? (y/N)"
            read answer 

            if [[ "$answer" = "${answer#[Yy]}" ]] ;then
                echo "Exiting..."
                exit 0;
            fi

            update_activation_code_input;

            update_activation_code_exec;

            echo "Your activation code has been successfully updated!"
            echo "Make sure to run 'hollaex restart' to fully apply it."

        fi

    elif [[ "$CONNECT_DATABASE" ]]; then

        if ! command psql --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect postgresql-client at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for database connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-db" -o name | sed 's/pod\///' | head -n 1) 5432:5432 &
                sleep 5;
                
                echo "Opening local proxy on 5432 port of your machine..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                echo "Opening postgresql-client shell..."
                psql 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect PostgreSQL database at your Kubernetes which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-db > /dev/null 2>&1; then

                echo "Successfully detected the PostgreSQL DB created by HollaEx CLI."

                echo "Opening postgresql-client shell..."
                export PGUSER=$HOLLAEX_SECRET_DB_USERNAME
                export PGPASSWORD=$HOLLAEX_SECRET_DB_PASSWORD
                export PGDATABASE=$HOLLAEX_SECRET_DB_NAME
                export PGHOST=localhost

                psql 

                exit 0;

            else

                echo "Failed to detect PostgreSQL database at your machine which created by HollaEx CLI."
                echo "If you setup PostgreSQL database in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_REDIS" ]]; then

        if ! command rdcli --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect redis-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for Redis connection..."

                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-redis" -o name | sed 's/pod\///' | head -n 1) 6379:6379 &
                sleep 5;
                
                echo "Opening local proxy on 6379 port of your machine..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                echo "Opening redis-client shell..."
                redis-cli 

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect Redis at your Kubernetes which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-redis > /dev/null 2>&1; then

                echo "Successfully detected the Redis created by HollaEx CLI."

                echo "Opening redis-cli shell..."
                export REDISCLI_AUTH=$HOLLAEX_SECRET_REDIS_PASSWORD

                redis-cli 

                exit 0;

            else

                echo "Failed to detect Redis at your machine which created by HollaEx CLI."
                echo "If you setup Redis in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    elif [[ "$CONNECT_INFLUXDB" ]]; then

        if ! command influx --version > /dev/null 2>&1; then

            printf "\033[91mHollaEx CLI failed to detect influx-cli at your computer.\033[39m\n"
            echo "Please install it first, before proceeding."
            exit 1;
        
        fi

        if [[ "$USE_KUBERNETES" ]]; then 

            check_kubernetes_dependencies;

            if command kubectl get ns $ENVIRONMENT_EXCHANGE_NAME > /dev/null 2>&1 && command kubectl get pods -n $ENVIRONMENT_EXCHANGE_NAME -l app=$ENVIRONMENT_EXCHANGE_NAME-influxdb > /dev/null 2>&1; then

                echo "Successfully detected the InfluxDB created by HollaEx CLI."
                echo "Opening kube-proxy tunnel for InfluxDB connection..."
                
                echo "Opening local proxy on 8086 port of your machine..."
                kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME $(kubectl get pod --namespace $ENVIRONMENT_EXCHANGE_NAME -l "app=$ENVIRONMENT_EXCHANGE_NAME-influxdb" -o name | sed 's/pod\///' | head -n 1) 8086:8086 &
                sleep 5;

                echo "Opening influx-cli shell..."
                influx -database $HOLLAEX_SECRET_INFLUX_DB -username $HOLLAEX_SECRET_INFLUX_USER -password $HOLLAEX_SECRET_INFLUX_PASSWORD

                echo "Killing the opened proxy tunnel..."
                kill $(ps -ef | grep "kubectl port-forward --namespace $ENVIRONMENT_EXCHANGE_NAME" | awk '{print $2}' | head -n 1)

                exit 0;
            
            else

                echo "Failed to detect InfluxDB at your Kubernetes which created by HollaEx CLI."
                echo "If you setup InfluxDB in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        elif [[ ! "$USE_KUBERNETES" ]]; then

            check_docker_compose_dependencies;

            if command docker ps | grep $ENVIRONMENT_EXCHANGE_NAME-influxdb > /dev/null 2>&1; then

                echo "Successfully detected the influx-cli created by HollaEx CLI."

                echo "Opening influx-cli shell..."
                influx -database $HOLLAEX_SECRET_INFLUX_DB -username $HOLLAEX_SECRET_INFLUX_USER -password $HOLLAEX_SECRET_INFLUX_PASSWORD

                exit 0;

            else

                echo "Failed to detect InfluxDB at your machine which created by HollaEx CLI."
                echo "If you setup InfluxDB in a custom way, Please connect to it manually."
                exit 1;
            
            fi

        fi

    fi


elif [[ "$1" == "status" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        kubectl get deployment --namespace $ENVIRONMENT_EXCHANGE_NAME

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect HollaEx on this machine. Please try it again.\033[39m\n"

        else 

            docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME

        fi

    fi

    printf "\nCalling the exchange health page ($HOLLAEX_CONFIGMAP_API_HOST/v1/health) ...\n"

    if command curl $HOLLAEX_CONFIGMAP_API_HOST/v1/health; then 

        printf "\n\033[92mSuccessfully reached to the exchange health page.\033[39m\n"

    else 

        printf "\033[91m\nExchange health page is not responding. Please check the exchange is up.\033[39m\n"

    fi

    exit 0;

elif [[ "$1" == "logs" ]]; then

     while true; do
        [[ $# -eq 0 ]] && break
        case $1 in
            --path)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_CLI_INIT_PATH=$1
                echo "Your HollaEx Kit Path : $HOLLAEX_CLI_INIT_PATH."
                shift; continue
                ;;
            --target)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET=$1
                echo "Displaying Logs from $1..."
                shift; continue
                ;;
            --line)
                shift 
                case $1 in (-*|"") err_msg_l; print_usage; exit 1; esac
                HOLLAEX_LOGS_TARGET_LINE=$1
                shift; continue
                ;;
            --kube)
                USE_KUBERNETES=true
                echo "HollaEx CLI will use your Kubernetes cluster as a target."
                shift; continue
                ;;
            --*) 
                err_msg "Invalid option: $1"
                print_usage;
                exit 1;
                ;;
        esac
        shift
     done

    if [[ ! "$HOLLAEX_CLI_INIT_PATH" ]]; then

        HOLLAEX_CLI_INIT_PATH=$(pwd)
        CONFIG_FILE_PATH=$(pwd)/settings/*
        TEMPLATE_GENERATE_PATH=$(pwd)/templates
        INIT_PATH_CHECK=$(pwd)/.hollaex

    fi

    if [[ "$HOLLAEX_CLI_INIT_PATH" ]]; then

        CONFIG_FILE_PATH=$HOLLAEX_CLI_INIT_PATH/settings/*
        TEMPLATE_GENERATE_PATH=$HOLLAEX_CLI_INIT_PATH/templates
        INIT_PATH_CHECK=$HOLLAEX_CLI_INIT_PATH/.hollaex
        
    fi

    #Quit if necessary flags are missing
    if [[ ! "$CONFIG_FILE_PATH" ]] || [[ ! -f "$INIT_PATH_CHECK" ]]; then

        printf "\033[91mFailed to detect HollaEx Kit directory! Please re-check your path.\033[39m\n"
        print_usage;
        exit 1;

    fi
    
    for i in ${CONFIG_FILE_PATH[@]}; do
        source $i
    done

    source $SCRIPTPATH/tools_generator.sh
    load_config_variables;

    function hollaex_log_target_whitelist() {

        local whitelist=("api" "stream" "engine" "db" "redis" "influxdb")

        if ! command printf '%s\n' ${whitelist[@]} | grep $HOLLAEX_LOGS_TARGET > /dev/null; then
        
            printf "\033[91mError: Invalid target $HOLLAEX_LOGS_TARGET.\033[39m\n"
            echo "Command 'hollaex logs' only supports '${whitelist[@]}' as log target."
            echo "Pleases try it again."

            exit 1;

        fi
    }
    
    if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

        hollaex_log_target_whitelist;
    
    fi

    if [[ "$USE_KUBERNETES" ]]; then

        #Checking Kubernetes dependencies
        check_kubernetes_dependencies;

        function show_kubernetes_logs_simple() {

            if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-*-$HOLLAEX_LOGS_TARGET | cut -f1 -d " ")

            else 
                
                local POD_ID=$(kubectl get pods --namespace $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME | cut -f1 -d " ")
            
            fi

            for i in ${POD_ID[@]}; do

                printf "\nPod : $i\n"

                    if [[ $(kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail 10) ]]; then

                            kubectl logs $i --namespace $ENVIRONMENT_EXCHANGE_NAME --tail ${HOLLAEX_LOGS_TARGET_LINE:-10}

                    else 

                        echo "There are no logs for Pod : $i."

                    fi

                printf "\n"

            done;
        
        }

        show_kubernetes_logs_simple;

        printf "\n"
        echo "Displayed last ${HOLLAEX_LOGS_TARGET_LINE:-10} lines of logs from pod(s)."

        if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then
            
            echo "To see logs from specific pod(s), Please run 'hollaex logs --kube --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
            echo "For example, 'hollaex logs --kube --targer api --lines 20'."
        
        fi

    fi
    
    if [[ ! "$USE_KUBERNETES" ]]; then

        if [[ -z $(docker ps -a | grep $ENVIRONMENT_EXCHANGE_NAME) ]]; then

            printf "\033[91m\nFailed to detect $ENVIRONMENT_EXCHANGE_NAME on this machine. Please try it again.\033[39m\n"

        else 

            function show_docker_logs_simple() {

                if [[ "$HOLLAEX_LOGS_TARGET" ]]; then

                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME | grep $ENVIRONMENT_EXCHANGE_NAME-.*-$HOLLAEX_LOGS_TARGET)
                    echo $CONTAINER_ID

                else 
                
                    local CONTAINER_ID=$(docker ps -a --format "{{.Names}}" | grep $ENVIRONMENT_EXCHANGE_NAME)

                fi

                for i in ${CONTAINER_ID[@]}; do

                    printf "\nContainer : $i\n"

                    if [[ $(docker logs $i --tail 10) ]]; then

                            docker logs $i --tail ${HOLLAEX_LOGS_TARGET_LINE:-10}

                    else 

                        echo "There are no logs for container : $i."

                    fi

                    printf "\n"

                done;
            
            }

            show_docker_logs_simple;

            printf "\n"
            echo "Displayed last ${HOLLAEX_LOGS_TARGET_LINE:-10} lines of logs from container(s)."

            if [[ ! "$HOLLAEX_LOGS_TARGET" ]]; then

                echo "To see logs from specific container(s), Please run 'hollaex logs --target <NAME_OF_COMPONENT> --lines <LINES_OF_LOGS>'."
                echo "For example, 'hollaex logs --target api --lines 20'."
            
            fi

        fi

    fi

    exit 0;
 

elif [[ "$1" == "version" ]]; then
     
    /bin/cat << EOF

1ttffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffttt.
.@@@000000000000000000000000000000000000000000000000000000000000000000@@@,
.0@G                                                                  L@8,
.8@G     fLL:  ;LLt         ;00L:00C         ;LfLCCCC;                C@@,
.8@G    .@@@;  i@@8  :1fti, i@@G;@@0 ,ittti, t@@0ttfL1ttt..ttt,       C@@,
.8@G    .8@@0GG0@@G:0@@LG@@f;@@C;@@0.L00L8@@;1@@0LL.  t@@CC@@1        C@@,
.8@G    .8@@LttC@@GC@@t  8@@f@@C;@@G:LGCtG@@1i@@Gtt    1@@@8:         C@8,
.8@G    .@@@;  i@@0i@@81L@@Ci@@G;@@0f@@G10@@t1@@8ffLL1i8@C0@8;.1t;    C@@,
.8@G     tff,  :fft ,1LCCf; ,ff1,fft.1LCL1ff;:fffLLLf;fff ,fLf,;i:    ;ii.
.0@G
.@@@888888888888888888888888888888888888888888888888888888888888888888880.
1ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt.

HollaEx CLI : v$(cat $SCRIPTPATH/version), Made with <3 by bitHolla Inc.

EOF

else

    printf "\nInvalid Command. Please try it again.\n"
    print_usage;

    exit 1;

fi

exit 0;


